# Copyright (C) 2012-2023 Mujin, Inc.

# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

from . import json
from . import planningclient

import logging
log = logging.getLogger(__name__)

class HandEyeCalibrationPlanningClient(planningclient.PlanningClient):
    """Mujin planning client for the HandEyeCalibration task"""
    robot = None
    

    def __init__(
        self,
        robot,
        scenepk='',
        controllerip='',
        controllerusername='',
        controllerpassword='',
        controllerurl='',
        tasktype='handeyecalibration',
        slaverequestid=None,
        taskzmqport=7110,
        taskheartbeatport=7111,
        taskheartbeattimeout=7.0,
        ctx=None,
        author=None,
        **ignoredArgs  # Additional keyword args are not used, but allowed for easy initialization from a dictionary
    ):
        """Connects to the Mujin controller, initializes HandEyeCalibration task and sets up parameters

        Args:
            robot (str): Name of the robot, e.g. VP-5243I
            scenepk (str, optional): Primary key (pk) of the scene, e.g. irex_demo.mujin.dae
            controllerip (str): IP or hostname of the mujin controller, e.g. 172.17.0.2 or controller123
            controllerusername (str): Username for the Mujin controller, e.g. testuser
            controllerpassword (str): Password for the Mujin controller
            controllerurl (str, optional): (Deprecated. Use controllerip instead) URL of the mujin controller, e.g. http://controller14.
            tasktype (str, optional): Type of the task, e.g. 'binpicking', 'handeyecalibration', 'itlrealtimeplanning3'. Default: handeyecalibration
            taskzmqport (int, optional): Port of the task's ZMQ server, e.g. 7110
            taskheartbeatport (int, optional): Port of the task's ZMQ server's heartbeat publisher, e.g. 7111
            taskheartbeattimeout (float, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
            ctx (zmq.Context, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
        """
        self.robot = robot
        super(HandEyeCalibrationPlanningClient, self).__init__(taskzmqport=taskzmqport, taskheartbeatport=taskheartbeatport, taskheartbeattimeout=taskheartbeattimeout, tasktype=tasktype, scenepk=scenepk, ctx=ctx, slaverequestid=slaverequestid, controllerurl=controllerurl, controllerusername=controllerusername, controllerpassword=controllerpassword, author=author)

    def ExecuteCommand(self, taskparameters, **kwargs):
      if 'robot' not in taskparameters:
        taskparameters['robot'] = self.robot
      super(HandEyeCalibrationPlanningClient, self).ExecuteCommand(taskparameters=taskparameters, **kwargs)
    
    #
    # Generated commands
    #

    # ============== Auto-generated code starts here

    def ComputeCalibrationPoses(self, cameracontainername, primarysensorname, secondarysensornames, numsamples, calibboardvisibility, calibboardLinkName=None, calibboardGeomName=None, timeout=None, gridindex=None, robot=None, **ignoredArgs):
        """Compute a set of calibration poses that satisfy the angle constraints using latin hypercube sampling (or stratified sampling upon failure)

        Args:
            cameracontainername (str): The name of the container that the camera is observing.
            primarysensorname (str): Name of the primary sensor to be calibrated (attached to the robot)
            secondarysensornames (list[str]): Names of secondary sensors to be calibrated (assumed to be nearby the primary sensor)
            numsamples (int): Number of samples to take. A reasonable number is often between 5 and 25.
            calibboardvisibility (bool):
            calibboardLinkName (str, optional):
            calibboardGeomName (str, optional):
            timeout:
            gridindex:
            robot (str, optional): The name of the robot (modelName).
        """
        taskparameters = {
            'command': 'ComputeCalibrationPoses',
            'cameracontainername': cameracontainername,
            'primarysensorname': primarysensorname,
            'secondarysensornames': secondarysensornames,
            'numsamples': numsamples,
            'calibboardvisibility': calibboardvisibility,
        }
        if calibboardLinkName is not None:
            taskparameters['calibboardLinkName'] = calibboardLinkName
        if calibboardGeomName is not None:
            taskparameters['calibboardGeomName'] = calibboardGeomName
        if timeout is not None:
            taskparameters['timeout'] = timeout
        if gridindex is not None:
            taskparameters['gridindex'] = gridindex
        if robot is not None:
            taskparameters['robot'] = robot
        return self.ExecuteCommand(taskparameters)

    def SampleCalibrationConfiguration(self, cameracontainername, primarysensorname, secondarysensornames, gridindex, calibboardvisibility, calibboardLinkName=None, calibboardGeomName=None, minPatternTiltAngle=None, maxPatternTiltAngle=None, timeout=3000.0, robot=None, **ignoredArgs):
        """Sample a valid calibration pose inside the given voxel and find a corresponding IK solution.

        Args:
            cameracontainername (str): The name of the container that the camera is observing.
            primarysensorname (str): Name of the primary sensor to be calibrated (attached to the robot)
            secondarysensornames (list[str]): Names of secondary sensors to be calibrated (assumed to be nearby the primary sensor)
            gridindex (int): The index of the voxel
            calibboardvisibility (bool):
            calibboardLinkName (str, optional):
            calibboardGeomName (str, optional):
            minPatternTiltAngle (float, optional): The minimum tilt of the pattern in degrees. Default: 10 degrees
            maxPatternTiltAngle (float, optional): The maximum tilt of the pattern in degrees. Default: 30 degrees
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3000.0)
            robot (str, optional): The name of the robot (modelName).
        """
        taskparameters = {
            'command': 'SampleCalibrationConfiguration',
            'cameracontainername': cameracontainername,
            'primarysensorname': primarysensorname,
            'secondarysensornames': secondarysensornames,
            'gridindex': gridindex,
            'calibboardvisibility': calibboardvisibility,
        }
        if calibboardLinkName is not None:
            taskparameters['calibboardLinkName'] = calibboardLinkName
        if calibboardGeomName is not None:
            taskparameters['calibboardGeomName'] = calibboardGeomName
        if minPatternTiltAngle is not None:
            taskparameters['minPatternTiltAngle'] = minPatternTiltAngle
        if maxPatternTiltAngle is not None:
            taskparameters['maxPatternTiltAngle'] = maxPatternTiltAngle
        if timeout is not None:
            taskparameters['timeout'] = timeout
        if robot is not None:
            taskparameters['robot'] = robot
        return self.ExecuteCommand(taskparameters, timeout=timeout)


def ReloadModule(self, **kwargs):
      return self.ExecuteCommand({
            'command': 'ReloadModule',
      }, **kwargs)
    
# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
