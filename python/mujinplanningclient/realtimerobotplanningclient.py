# Copyright (C) 2012-2023 Mujin, Inc.

# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

from . import json
from . import planningclient

import logging
log = logging.getLogger(__name__)

class RealtimeRobotPlanningClient(planningclient.PlanningClient):
    """Mujin planning client for the RealtimeRobot task"""
    _robotname = None  # Optional name of the robot selected
    _robotspeed = None  # Speed of the robot, e.g. 0.4
    _robotaccelmult = None  # Current robot accel mult
    _envclearance = None  # Environment clearance in millimeters, e.g. 20
    _robotBridgeConnectionInfo = None  # dict holding the connection info for the robot bridge.
    

    def __init__(
        self,
        robotname='',
        robotspeed=None,
        robotaccelmult=None,
        envclearance=10.0,
        robotBridgeConnectionInfo=None,
        scenepk='',
        controllerip='',
        controllerusername='',
        controllerpassword='',
        controllerurl='',
        tasktype='realtimerobot',
        slaverequestid=None,
        taskzmqport=7110,
        taskheartbeatport=7111,
        taskheartbeattimeout=7.0,
        ctx=None,
        author=None,
        **ignoredArgs  # Additional keyword args are not used, but allowed for easy initialization from a dictionary
    ):
        """Connects to the Mujin controller, initializes RealtimeRobot task and sets up parameters

        Args:
            robotname (str, optional): Name of the robot, e.g. VP-5243I
            robotspeed (float, optional): Speed of the robot, e.g. 0.4
            robotaccelmult (float, optional): Optional multiplier for the robot acceleration.
            envclearance (str, optional): Environment clearance in millimeter, e.g. 20
            robotBridgeConnectionInfo (str, optional): dict holding the connection info for the robot bridge.
            scenepk (str, optional): Primary key (pk) of the scene, e.g. irex_demo.mujin.dae
            controllerip (str): IP or hostname of the mujin controller, e.g. 172.17.0.2 or controller123
            controllerusername (str): Username for the Mujin controller, e.g. testuser
            controllerpassword (str): Password for the Mujin controller
            controllerurl (str, optional): (Deprecated. Use controllerip instead) URL of the mujin controller, e.g. http://controller14.
            tasktype (str, optional): Type of the task, e.g. 'binpicking', 'handeyecalibration', 'itlrealtimeplanning3'. Default: realtimerobot
            taskzmqport (int, optional): Port of the task's ZMQ server, e.g. 7110
            taskheartbeatport (int, optional): Port of the task's ZMQ server's heartbeat publisher, e.g. 7111
            taskheartbeattimeout (float, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
            ctx (zmq.Context, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
        """
        self._robotname = robotname
        self._robotspeed = robotspeed
        self._robotaccelmult = robotaccelmult
        self._envclearance = envclearance
        self._robotBridgeConnectionInfo = robotBridgeConnectionInfo
        super(RealtimeRobotPlanningClient, self).__init__(taskzmqport=taskzmqport, taskheartbeatport=taskheartbeatport, taskheartbeattimeout=taskheartbeattimeout, tasktype=tasktype, scenepk=scenepk, ctx=ctx, slaverequestid=slaverequestid, controllerurl=controllerurl, controllerusername=controllerusername, controllerpassword=controllerpassword, author=author)

    def GetRobotConnectionInfo(self):
        """ """
        return self._robotBridgeConnectionInfo

    def SetRobotConnectionInfo(self, robotBridgeConnectionInfo):
        """

        Args:
            robotBridgeConnectionInfo:
        """
        self._robotBridgeConnectionInfo = robotBridgeConnectionInfo

    def GetRobotName(self):
        """ """
        return self._robotname

    def SetRobotName(self, robotname):
        """

        Args:
            robotname (str):
        """
        self._robotname = robotname

    def SetRobotSpeed(self, robotspeed):
        """

        Args:
            robotspeed:
        """
        self._robotspeed = robotspeed

    def SetRobotAccelMult(self, robotaccelmult):
        """

        Args:
            robotaccelmult:
        """
        self._robotaccelmult = robotaccelmult

    def ExecuteCommand(self, taskparameters, robotname=None, toolname=None, robotspeed=None, robotaccelmult=None, envclearance=None, timeout=10, fireandforget=False, respawnopts=None):
        """Wrapper to ExecuteCommand with robot info specified in taskparameters.

        Executes a command in the task.

        Args:
            taskparameters (dict): Specifies the arguments of the task/command being called.
            robotname (str, optional): Name of the robot
            robotaccelmult (float, optional):
            envclearance (float, optional):
            respawnopts (optional):
            toolname (str, optional): Name of the manipulator.
            timeout (float, optional):  (Default: 10)
            fireandforget (bool, optional):  (Default: False)
            robotspeed (float, optional):

        Returns:
            dict: Contains:
                - robottype (str): robot type
                - currentjointvalues (list[float]): current joint values, vector length = DOF
                - elapsedtime (float): elapsed time in seconds
                - numpoints (int): the number of points
                - error (dict): optional error info
                - desc (str): error message
                - type (str): error type
                - errorcode (str): error code
        """
        if robotname is None:
            robotname = self._robotname

        # caller wants to use a different tool
        if toolname is not None:
            # set at the first level
            taskparameters['toolname'] = toolname

        if robotname is not None:
            taskparameters['robotname'] = robotname

        if 'robotspeed' not in taskparameters:
            if robotspeed is None:
                robotspeed = self._robotspeed
            if robotspeed is not None:
                taskparameters['robotspeed'] = robotspeed

        if 'robotaccelmult' not in taskparameters:
            if robotaccelmult is None:
                robotaccelmult = self._robotaccelmult
            if robotaccelmult is not None:
                taskparameters['robotaccelmult'] = robotaccelmult

        if self._robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = self._robotBridgeConnectionInfo

        if 'envclearance' not in taskparameters or taskparameters['envclearance'] is None:
            if envclearance is None:
                envclearance = self._envclearance
            if envclearance is not None:
                taskparameters['envclearance'] = envclearance

        return super(RealtimeRobotPlanningClient, self).ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget, respawnopts=respawnopts)
    
    #
    # Generated commands
    #

    # ============== Auto-generated code starts here

    def GetJointValues(self, timeout=10, executetimeout=10, unit='mm', locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None):
        """Gets the current robot joint values

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            executetimeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool

        Returns:
            Current joint values in a json dictionary with key currentjointvalues and value [0,0,0,0,0,0]

        """
        taskparameters = {
            'command': 'GetJointValues',
            'executetimeout': executetimeout,
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveToolLinear(
        self,
        goaltype,
        goals,
        toolname=None,
        timeout=10,
        robotspeed=None,
        workmaxdeviationangle=None,
        workspeed=None,
        workaccel=None,
        worksteplength=None,
        plannername=None,
        workminimumcompletetime=None,
        workminimumcompleteratio=None,
        numspeedcandidates=None,
        workignorefirstcollisionee=None,
        workignorelastcollisionee=None,
        workignorefirstcollision=None,
        currentlimitratios=None,
        execute=None,
        ignoreGrabbingTarget=None,
        ikparamname=None,
        instobjectname=None,
        ionames=None,
        locationCollisionInfos=None,
        moveStraightParams=None,
        robotBridgeConnectionInfo=None,
        robotaccelmult=None,
        robotname=None,
        unit='mm',
    ):
        """Moves the tool linearly in cartesian (3D) space.

        Args:
            goaltype (str): Type of the goal, e.g. translationdirection5d
            goals (list[float]): Flat list of goals, e.g. two 5D ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            toolname (str, optional): Tool name(s)
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            workmaxdeviationangle (float, optional): How much the tool tip can rotationally deviate from the linear path. In deg.
            workspeed (list[float], optional): [anglespeed, transspeed] in deg/s and mm/s
            workaccel (list[float], optional): [angleaccel, transaccel] in deg/s^2 and mm/s^2
            worksteplength (float, optional): Discretization for planning MoveHandStraight, in seconds.
            plannername (str, optional):
            workminimumcompletetime (float, optional): (DEPRECATED, UNUSED) Set to trajduration - 0.016s. EMU_MUJIN example requires at least this much
            workminimumcompleteratio (float, optional): (DEPRECATED, UNUSED) In case the duration of the trajectory is now known, can specify in terms of [0,1]. 1 is complete everything.
            numspeedcandidates (int, optional): If speed/accel are not specified, the number of candiates to consider
            workignorefirstcollisionee (float, optional): time, necessary in case initial is in collision, has to be multiples of step length?
            workignorelastcollisionee (float, optional): time, necessary in case goal is in collision, has to be multiples of step length?
            workignorefirstcollision (float, optional):
            currentlimitratios (list[float], optional): The joints' current limit ratios.
            execute:
            ignoreGrabbingTarget (bool, optional):
            ikparamname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            instobjectname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            moveStraightParams: A set of parameters defining how the robot behaves during linear motions.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'MoveToolLinear',
            'goals': goals,
            'goaltype': goaltype,
            'unit': unit,
        }
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if execute is not None:
            taskparameters['execute'] = execute
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if ikparamname is not None:
            taskparameters['ikparamname'] = ikparamname
        if instobjectname is not None:
            taskparameters['instobjectname'] = instobjectname
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if numspeedcandidates is not None:
            taskparameters['numspeedcandidates'] = numspeedcandidates
        if plannername is not None:
            taskparameters['plannername'] = plannername
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if workaccel is not None:
            taskparameters['workaccel'] = workaccel
        if workignorefirstcollision is not None:
            taskparameters['workignorefirstcollision'] = workignorefirstcollision
        if workignorefirstcollisionee is not None:
            taskparameters['workignorefirstcollisionee'] = workignorefirstcollisionee
        if workignorelastcollisionee is not None:
            taskparameters['workignorelastcollisionee'] = workignorelastcollisionee
        if workmaxdeviationangle is not None:
            taskparameters['workmaxdeviationangle'] = workmaxdeviationangle
        if workminimumcompleteratio is not None:
            taskparameters['workminimumcompleteratio'] = workminimumcompleteratio
        if workminimumcompletetime is not None:
            taskparameters['workminimumcompletetime'] = workminimumcompletetime
        if workspeed is not None:
            taskparameters['workspeed'] = workspeed
        if worksteplength is not None:
            taskparameters['worksteplength'] = worksteplength
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveToHandPosition(
        self,
        goaltype,
        goals,
        toolname=None,
        envclearance=None,
        closegripper=0,
        robotspeed=None,
        robotaccelmult=None,
        timeout=10,
        chuckgripper=None,
        ikparamname=None,
        ikparamoffset=None,
        instobjectname=None,
        ionames=None,
        locationCollisionInfos=None,
        minimumgoalpaths=None,
        moveStraightParams=None,
        pathPlannerParameters=None,
        robotBridgeConnectionInfo=None,
        robotname=None,
        smootherParameters=None,
        unit='mm',
    ):
        """Computes the inverse kinematics and moves the manipulator to any one of the goals specified.

        Args:
            goaltype (str): Type of the goal, e.g. translationdirection5d
            goals (list[float]): Flat list of goals, e.g. two 5d ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            envclearance (float, optional): Environment clearance in millimeters.
            closegripper (bool, optional): (DEPRECATED) Whether to close gripper once the goal is reached. (Default: 0)
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            chuckgripper (bool, optional):
            ikparamname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ikparamoffset (list[float], optional):
            instobjectname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            minimumgoalpaths (int, optional): Number of solutions the planner must provide before it is allowed to finish.
            moveStraightParams: A set of parameters defining how the robot behaves during linear motions.
            pathPlannerParameters:
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            smootherParameters:
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'MoveToHandPosition',
            'closegripper': closegripper,
            'goals': goals,
            'goaltype': goaltype,
            'unit': unit,
        }
        if chuckgripper is not None:
            taskparameters['chuckgripper'] = chuckgripper
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if ikparamname is not None:
            taskparameters['ikparamname'] = ikparamname
        if ikparamoffset is not None:
            taskparameters['ikparamoffset'] = ikparamoffset
        if instobjectname is not None:
            taskparameters['instobjectname'] = instobjectname
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if minimumgoalpaths is not None:
            taskparameters['minimumgoalpaths'] = minimumgoalpaths
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if pathPlannerParameters is not None:
            taskparameters['pathPlannerParameters'] = pathPlannerParameters
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if smootherParameters is not None:
            taskparameters['smootherParameters'] = smootherParameters
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def UpdateObjects(
        self,
        envstate,
        targetname=None,
        state=None,
        unit='mm',
        timeout=10,
        addPointOffsetInfo=None,
        addUnpickableRegionAcrossShortEdgeDist=None,
        belowBoxOverlap=0,
        callerid=None,
        cameranames=None,
        castPointCloudShadowFromCamera=None,
        clampToContainer=None,
        containerName=None,
        countOverlappingPoints=None,
        cropContainerMarginsXYZXYZ=None,
        detectionResultState=None,
        ignoreOverlapPointsFromNearbyTargets=0,
        ignoreOverlapPointsFromWall=0,
        imageEndTimeStampMS=None,
        imageStartTimeStampMS=None,
        ioSignalsInfo=None,
        isFromStateSlaveNotify=None,
        locationContainerId=None,
        locationName=None,
        medianFilterHalfSize=None,
        object_uri=None,
        overlapUpAxis=None,
        pointCloudSensorTimeStampMS=None,
        pointcloudid=None,
        points=None,
        pointsProjectedDirection=None,
        pointsize=None,
        randomBoxOrigin=None,
        rollStepDegree=90,
        sizePrecisionXYZ=None,
        sizeRoundUp=None,
        targetUpdateNamePrefix=None,
        useEmptyRegionForCropping=None,
        zthresholdmult=None,
    ):
        """Updates objects in the scene with the envstate

        Args:
            envstate: A list of dictionaries for each instance object in world frame. Quaternion is specified in w,x,y,z order. e.g. [{'name': 'target_0', 'translation_': [1,2,3], 'quat_': [1,0,0,0], 'object_uri':'mujin:/asdfas.mujin.dae'}, {'name': 'target_1', 'translation_': [2,2,3], 'quat_': [1,0,0,0]}]
            targetname (str, optional): Name of the target object
            state (dict, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            addPointOffsetInfo (dict, optional): Special offsets from pointcloud
            addUnpickableRegionAcrossShortEdgeDist (bool, optional):
            belowBoxOverlap (float, optional): mm, Threshold on how much to ignore the relative heights of two neighboring targets to determine if the candidate is *below* the current pickup target. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes detection error can cause two targets on the same height to be overlapped a little, but that doesn't mean that one target is on top of the other. (Default: 0)
            callerid (str, optional): The name of the caller (only used internally)
            cameranames (list[str], optional):
            castPointCloudShadowFromCamera (bool, optional): If True, bottom parts of pointcloud obstacle are generated by casting shadow from camera. otherwise, vertical down (-z).
            clampToContainer (bool, optional): If True, crop to container dimensions.
            containerName (str, optional): Name of the container to update. Requires locationName to be set. If containerName is empty, will use the container in locationName.
            countOverlappingPoints (bool, optional):
            cropContainerMarginsXYZXYZ (list, optional): Margin defining an axis aligned bounding box to limit point cloud data for the container. Values are measured from the interior of container edges. Positive value means cropping, negative value means additional margin. 
            detectionResultState (dict, optional): Information about the detected objects (received from detectors)
            ignoreOverlapPointsFromNearbyTargets (float, optional): mm, amount of target extents reduction when counting the number of overlapping pointcloud points. This is so that pointcloud near the edges of the target (can come from noises from nearby targets, for example) can be ignored. (Default: 0)
            ignoreOverlapPointsFromWall (float, optional): mm, distance from the container inner walls within which pointcloud points do not count towards overlapping points (Default: 0)
            imageEndTimeStampMS (int, optional):
            imageStartTimeStampMS (int, optional):
            ioSignalsInfo (dict, optional): Struct for dictating if any IO signals should be written on receiving detection results
            isFromStateSlaveNotify (bool, optional):
            locationContainerId:
            locationName (str, optional): Name of the location to update.
            medianFilterHalfSize (float, optional): If clampcontainer is True, this is used for filtering.
            object_uri (str, optional): Same as objectname, but in a Mujin URI format, e.g.: mujin:/OBJECTNAME.mujin.dae
            overlapUpAxis (list, optional):
            pointCloudSensorTimeStampMS (int, optional):
            pointcloudid (str, optional):
            points (list[float], optional): The point cloud passed in along with the detection results. Used in selective cases to count point overlap of random box.
            pointsProjectedDirection (list, optional): The negative direction in which the points were projected when creating the obstacles. If specified, then take into account when computing the overlap. When container up is +Z, then pointsProjectedDirection will be (0,0,1).
            pointsize (float, optional): Size of points in the point cloud.
            randomBoxOrigin (list, optional): Specifies where to place the origin of the incoming box detections. By default, this is [0,0,1], which means the origin will be at the center of the +Z (top) face.
            rollStepDegree (float, optional): Step of 6D grasp rotation around z axis in degrees, defaults to 45 degrees. (Default: 90)
            sizePrecisionXYZ (list, optional): mm (x,y,z) for rounding up incoming boxes from the detector. This allows previous grasping models to be cached and re-used since the sizes will be multiples of the current precision.
            sizeRoundUp (bool, optional): If False, then round down. (Default: True)
            targetUpdateNamePrefix (str, optional):
            useEmptyRegionForCropping (bool, optional): If clampcontainer is True, this is used for filtering.
            zthresholdmult (float, optional):
        """
        taskparameters = {
            'command': 'UpdateObjects',
            'belowBoxOverlap': belowBoxOverlap,
            'envstate': envstate,
            'ignoreOverlapPointsFromNearbyTargets': ignoreOverlapPointsFromNearbyTargets,
            'ignoreOverlapPointsFromWall': ignoreOverlapPointsFromWall,
            'rollStepDegree': rollStepDegree,
            'unit': unit,
        }
        if addPointOffsetInfo is not None:
            taskparameters['addPointOffsetInfo'] = addPointOffsetInfo
        if addUnpickableRegionAcrossShortEdgeDist is not None:
            taskparameters['addUnpickableRegionAcrossShortEdgeDist'] = addUnpickableRegionAcrossShortEdgeDist
        if callerid is not None:
            taskparameters['callerid'] = callerid
        if cameranames is not None:
            taskparameters['cameranames'] = cameranames
        if castPointCloudShadowFromCamera is not None:
            taskparameters['castPointCloudShadowFromCamera'] = castPointCloudShadowFromCamera
        if clampToContainer is not None:
            taskparameters['clampToContainer'] = clampToContainer
        if containerName is not None:
            taskparameters['containerName'] = containerName
        if countOverlappingPoints is not None:
            taskparameters['countOverlappingPoints'] = countOverlappingPoints
        if cropContainerMarginsXYZXYZ is not None:
            taskparameters['cropContainerMarginsXYZXYZ'] = cropContainerMarginsXYZXYZ
        if detectionResultState is not None:
            taskparameters['detectionResultState'] = detectionResultState
        if imageEndTimeStampMS is not None:
            taskparameters['imageEndTimeStampMS'] = imageEndTimeStampMS
        if imageStartTimeStampMS is not None:
            taskparameters['imageStartTimeStampMS'] = imageStartTimeStampMS
        if ioSignalsInfo is not None:
            taskparameters['ioSignalsInfo'] = ioSignalsInfo
        if isFromStateSlaveNotify is not None:
            taskparameters['isFromStateSlaveNotify'] = isFromStateSlaveNotify
        if locationContainerId is not None:
            taskparameters['locationContainerId'] = locationContainerId
        if locationName is not None:
            taskparameters['locationName'] = locationName
        if medianFilterHalfSize is not None:
            taskparameters['medianFilterHalfSize'] = medianFilterHalfSize
        if object_uri is not None:
            taskparameters['object_uri'] = object_uri
        if overlapUpAxis is not None:
            taskparameters['overlapUpAxis'] = overlapUpAxis
        if pointCloudSensorTimeStampMS is not None:
            taskparameters['pointCloudSensorTimeStampMS'] = pointCloudSensorTimeStampMS
        if pointcloudid is not None:
            taskparameters['pointcloudid'] = pointcloudid
        if points is not None:
            taskparameters['points'] = points
        if pointsProjectedDirection is not None:
            taskparameters['pointsProjectedDirection'] = pointsProjectedDirection
        if pointsize is not None:
            taskparameters['pointsize'] = pointsize
        if randomBoxOrigin is not None:
            taskparameters['randomBoxOrigin'] = randomBoxOrigin
        if sizePrecisionXYZ is not None:
            taskparameters['sizePrecisionXYZ'] = sizePrecisionXYZ
        if sizeRoundUp is not None:
            taskparameters['sizeRoundUp'] = sizeRoundUp
        if state is not None:
            taskparameters['state'] = json.dumps(state)
        if targetUpdateNamePrefix is not None:
            taskparameters['targetUpdateNamePrefix'] = targetUpdateNamePrefix
        if targetname is not None:
            taskparameters['objectname'] = targetname
            taskparameters['object_uri'] = u'mujin:/%s.mujin.dae' % (targetname)
        if useEmptyRegionForCropping is not None:
            taskparameters['useEmptyRegionForCropping'] = useEmptyRegionForCropping
        if zthresholdmult is not None:
            taskparameters['zthresholdmult'] = zthresholdmult
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def Grab(self, targetname, toolname=None, timeout=10):
        """Grabs an object with tool

        Args:
            targetname (str): Name of the target object
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'Grab',
            'targetname': targetname,
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def Release(self, targetname, timeout=10):
        """Releases a grabbed object.

        Args:
            targetname (str): Name of the target object
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'Release',
            'targetname': targetname,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetGrabbed(self, timeout=10):
        """Gets the names of the objects currently grabbed

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            Names of the grabbed object in a JSON dictionary, e.g. {'names': ['target_0']}

        """
        taskparameters = {
            'command': 'GetGrabbed',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetTransform(self, targetname, connectedBodyName=None, linkName=None, geometryName=None, geometryPk=None, unit='mm', timeout=10):
        """Gets the transform of an object

        Args:
            targetname (str): OpenRave Kinbody name
            connectedBodyName (str, optional): OpenRave connected body name
            linkName (str, optional): OpenRave link name
            geometryName (str, optional): OpenRave geometry id name
            geometryPk (str, optional): OpenRave geometry primary key (pk)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            Transform of the object in a JSON dictionary, e.g. {'translation': [100,200,300], 'rotationmat': [[1,0,0],[0,1,0],[0,0,1]], 'quaternion': [1,0,0,0]}

        """
        taskparameters = {
            'command': 'GetTransform',
            'targetname': targetname,
            'unit': unit,
        }
        if connectedBodyName is not None:
            taskparameters['connectedBodyName'] = connectedBodyName
        if geometryName is not None:
            taskparameters['geometryName'] = geometryName
        if geometryPk is not None:
            taskparameters['geometryPk'] = geometryPk
        if linkName is not None:
            taskparameters['linkName'] = linkName
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetTransform(self, targetname, translation, unit='mm', rotationmat=None, quaternion=None, timeout=10):
        """Sets the transform of an object. Rotation can be specified by either quaternion or rotation matrix.

        Args:
            targetname (str): Name of the target object
            translation (list[float]): List of x,y,z values of the object in millimeters.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            rotationmat (list[float], optional): List specifying the rotation matrix in row major format, e.g. [1,0,0,0,1,0,0,0,1]
            quaternion (list[float], optional): List specifying the quaternion in w,x,y,z format, e.g. [1,0,0,0].
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'SetTransform',
            'targetname': targetname,
            'translation': translation,
            'unit': unit,
        }
        if quaternion is not None:
            taskparameters['quaternion'] = quaternion
        if rotationmat is not None:
            taskparameters['rotationmat'] = rotationmat
        if rotationmat is None and quaternion is None:
            taskparameters['quaternion'] = [1, 0, 0, 0]
            log.warn('No rotation is specified. Using identity quaternion.')
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetOBB(self, targetname, unit='mm', timeout=10, linkname=None):
        """Get the oriented bounding box (OBB) of object.

        Args:
            targetname (str): Name of the object
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            linkname (str, optional): Name of link to use for OBB. If not specified, uses entire target.

        Returns:
            A dictionary describing the OBB of the object with keys: extents, boxLocalTranslation, originalBodyTranslation, quaternion, rotationmat, translation

        """
        taskparameters = {
            'command': 'GetOBB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInnerEmptyRegionOBB(self, targetname, linkname=None, unit='mm', timeout=10):
        """Get the inner empty oriented bounding box (OBB) of a container.

        Args:
            targetname (str): Name of the object
            linkname (str, optional): Name of link to use for OBB. If not specified, uses entire target.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            A dict describing the OBB of the object with keys: extents, boxLocalTranslation, originalBodyTranslation, quaternion, rotationmat, translation

        """
        taskparameters = {
            'command': 'GetInnerEmptyRegionOBB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInstObjectAndSensorInfo(self, instobjectnames=None, sensornames=None, unit='mm', timeout=10, ignoreMissingObjects=None):
        """Returns information about the inst objects and sensors that are a part of those inst objects.

        Args:
            instobjectnames (list[str], optional):
            sensornames (list[str], optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ignoreMissingObjects (bool, optional): If False, will raise an error if the object is not found in the scene. Default: True.
        """
        taskparameters = {
            'command': 'GetInstObjectAndSensorInfo',
            'unit': unit,
        }
        if ignoreMissingObjects is not None:
            taskparameters['ignoreMissingObjects'] = ignoreMissingObjects
        if instobjectnames is not None:
            taskparameters['instobjectnames'] = instobjectnames
        if sensornames is not None:
            taskparameters['sensornames'] = sensornames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInstObjectInfoFromURI(self, instobjecturi=None, unit='mm', timeout=10, instobjectpose=None):
        """Opens a URI and returns info about the internal/external and geometry info from it.

        Args:
            instobjecturi (str, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            instobjectpose (list[float], optional): Pose to be assigned to the retrieved object. 7-element list
        """
        taskparameters = {
            'command': 'GetInstObjectInfoFromURI',
            'unit': unit,
        }
        if instobjectpose is not None:
            taskparameters['instobjectpose'] = instobjectpose
        if instobjecturi is not None:
            taskparameters['objecturi'] = instobjecturi
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetAABB(self, targetname, unit='mm', timeout=10, linkname=None):
        """Gets the axis-aligned bounding box (AABB) of an object.

        Args:
            targetname (str): Name of the object
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            linkname (str, optional): Name of link to use for the AABB. If not specified, uses entire target.

        Returns:
            AABB of the object, e.g. {'pos': [1000,400,100], 'extents': [100,200,50]}

        """
        taskparameters = {
            'command': 'GetAABB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetLocationTracking(self, timeout=10, fireandforget=False, cycleIndex=None, locationReplaceInfos=None, removeLocationNames=None, minRobotBridgeTimeStampUS=None, dynamicObstacleBaseName=None, targetUpdateBaseName=None, ioSignalsInfo=None, unit='mm'):
        """Resets the tracking of specific containers

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            cycleIndex: The cycle index to track the locations for
            locationReplaceInfos: A dict that should have the keys: name, containerDynamicProperties, rejectContainerIds, uri, pose, cycleIndex
            removeLocationNames (list[str], optional):
            minRobotBridgeTimeStampUS (int, optional): The minimum expected time stamp.
            dynamicObstacleBaseName (str, optional):
            targetUpdateBaseName (str, optional):
            ioSignalsInfo (dict, optional): Struct for dictating if any IO signals should be written on receiving detection results
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetLocationTracking',
            'unit': unit,
        }
        if cycleIndex is not None:
            taskparameters['cycleIndex'] = cycleIndex
        if dynamicObstacleBaseName is not None:
            taskparameters['dynamicObstacleBaseName'] = dynamicObstacleBaseName
        if ioSignalsInfo is not None:
            taskparameters['ioSignalsInfo'] = ioSignalsInfo
        if locationReplaceInfos is not None:
            taskparameters['locationReplaceInfos'] = locationReplaceInfos
        if minRobotBridgeTimeStampUS is not None:
            taskparameters['minRobotBridgeTimeStampUS'] = minRobotBridgeTimeStampUS
        if removeLocationNames is not None:
            taskparameters['removeLocationNames'] = removeLocationNames
        if targetUpdateBaseName is not None:
            taskparameters['targetUpdateBaseName'] = targetUpdateBaseName
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetLocationTracking(self, timeout=10, fireandforget=False, resetAllLocations=None, resetLocationName=None, resetLocationNames=None, checkIdAndResetLocationName=None):
        """Resets tracking updates for locations

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            resetAllLocations (bool, optional): If True, then will reset all the locations
            resetLocationName (str, optional): Resets only the location with matching name
            resetLocationNames (list[str], optional): Resets only locations with matching name
            checkIdAndResetLocationName: (locationName, containerId) - only reset the location if the container id matches

        Returns:
            clearedLocationNames

        """
        taskparameters = {
            'command': 'ResetLocationTracking',
        }
        if checkIdAndResetLocationName is not None:
            taskparameters['checkIdAndResetLocationName'] = checkIdAndResetLocationName
        if resetAllLocations is not None:
            taskparameters['resetAllLocations'] = resetAllLocations
        if resetLocationName is not None:
            taskparameters['resetLocationName'] = resetLocationName
        if resetLocationNames is not None:
            taskparameters['resetLocationNames'] = resetLocationNames
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget).get('clearedLocationNames', None)

    def GetLocationTrackingInfos(self, fireandforget=False, timeout=10):
        """Gets the active tracked locations

        Args:
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            activeLocationTrackingInfos

        """
        taskparameters = {
            'command': 'GetLocationTrackingInfos',
        }
        return self.ExecuteCommand(taskparameters, fireandforget=fireandforget, timeout=timeout).get('activeLocationTrackingInfos', None)

    def UpdateLocationContainerIdType(self, locationName, containerName, containerId, containerType, trackingCycleIndex=None, timeout=10, fireandforget=False, unit='mm'):
        """Resets the tracking of specific containers

        Args:
            locationName (str): Name of the location the container is in
            containerName (str): Name of the container
            containerId (str): ID of the container
            containerType (str): Type of the container
            trackingCycleIndex: If specified, then the cycle with same cycleIndex will update location tracking in the same call.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'UpdateLocationContainerIdType',
            'containerId': containerId,
            'containerName': containerName,
            'containerType': containerType,
            'locationName': locationName,
            'unit': unit,
        }
        if trackingCycleIndex is not None:
            taskparameters['trackingCycleIndex'] = trackingCycleIndex
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetLocationTrackingContainerId(self, locationName, checkContainerId, timeout=10, fireandforget=False):
        """Resets the containerId of self._activeLocationTrackingInfos if it matches checkContainerId.

        Args:
            locationName (str): The name of the location that may be reset.
            checkContainerId: If checkContainerId is specified and not empty and it matches the current containerId of the tracking location, then reset the current tracking location
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetLocationTrackingContainerId',
            'checkContainerId': checkContainerId,
            'locationName': locationName,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def RemoveObjectsWithPrefix(self, prefix=None, removeNamePrefixes=None, timeout=10, fireandforget=False, removeLocationNames=None, doRemoveOnlyDynamic=None, callerid=None, imageStartTimeStampMS=None, locationContainerId=None, locationName=None):
        """Removes objects with prefix.

        Args:
            prefix (str, optional): (DEPRECATED)
            removeNamePrefixes (list[str], optional): Names of prefixes to match with when removing items
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            removeLocationNames (list[str], optional):
            doRemoveOnlyDynamic (bool, optional): If True, removes objects that were added through dynamic means such as UpdateObjects/UpdateEnvironmentState. Default: False
            callerid (str, optional): The name of the caller (only used internally)
            imageStartTimeStampMS (int, optional):
            locationContainerId:
            locationName (str, optional): Name of the location to update.

        Returns:
            With key 'removedBodyNames' for the removed object names

        """
        taskparameters = {
            'command': 'RemoveObjectsWithPrefix',
        }
        if callerid is not None:
            taskparameters['callerid'] = callerid
        if doRemoveOnlyDynamic is not None:
            taskparameters['doRemoveOnlyDynamic'] = doRemoveOnlyDynamic
        if imageStartTimeStampMS is not None:
            taskparameters['imageStartTimeStampMS'] = imageStartTimeStampMS
        if locationContainerId is not None:
            taskparameters['locationContainerId'] = locationContainerId
        if locationName is not None:
            taskparameters['locationName'] = locationName
        if prefix is not None:
            taskparameters['prefix'] = prefix
        if removeLocationNames is not None:
            taskparameters['removeLocationNames'] = removeLocationNames
        if removeNamePrefixes is not None:
            taskparameters['removeNamePrefixes'] = removeNamePrefixes
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetTrajectoryLog(self, timeout=10, startindex=None, num=None, includejointvalues=False, saverawtrajectories=None):
        """Gets the recent trajectories executed on the binpicking server. The internal server keeps trajectories around for 10 minutes before clearing them.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            startindex (int, optional): Start of the trajectory to get. If negative, will start counting from the end. For example, -1 is the last element, -2 is the second to last. Default: 0
            num (int, optional): Number of trajectories from startindex to return. If 0, will return all the trajectories starting from startindex. Default: 0
            includejointvalues (bool, optional): If True, will include timedjointvalues. If False, will just give back the trajectories.
            saverawtrajectories (bool, optional): If True, will save the raw trajectories.

        Returns:
            A dict with structure: 
                total: 10
                trajectories: [
                {
                "timestarted": 12345215
                "name": "movingtodest",
                "numpoints": 100,
                "duration": 0.8,
                "timedjointvalues": [0, 0, 0, .....]
                },
                { ... }
                ]
                
                Where timedjointvalues is a list of joint values and the trajectory time. For a 3DOF robot sampled at 0.008s, this is
                [J1, J2, J3, 0, J1, J2, J3, 0.008, J1, J2, J3, 0.016, ...]

        """
        taskparameters = {
            'command': 'GetTrajectoryLog',
            'includejointvalues': includejointvalues,
        }
        if num is not None:
            taskparameters['num'] = num
        if saverawtrajectories is not None:
            taskparameters['saverawtrajectories'] = saverawtrajectories
        if startindex is not None:
            taskparameters['startindex'] = startindex
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ChuckGripper(self, robotname=None, grippername=None, timeout=10, toolname=None, ionames=None, robotaccelmult=None, robotspeed=None):
        """Chucks the manipulator

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            ionames (list, optional): A list of IO names to read/write
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
        """
        taskparameters = {
            'command': 'ChuckGripper',
        }
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def UnchuckGripper(self, robotname=None, grippername=None, timeout=10, targetname=None, toolname=None, pulloutdist=None, deletetarget=None, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotspeed=None, unit='mm'):
        """Unchucks the manipulator and releases the target

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            targetname (str, optional): Name of the target object.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            pulloutdist (float, optional): Distance to move away along the tool direction after releasing.
            deletetarget (int, optional): If 1, removes the target object from the environment after releasing. (Default: 1)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'UnchuckGripper',
            'unit': unit,
        }
        if deletetarget is not None:
            taskparameters['deletetarget'] = deletetarget
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if pulloutdist is not None:
            taskparameters['pulloutdist'] = pulloutdist
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if targetname is not None:
            taskparameters['targetname'] = targetname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def CalibrateGripper(self, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, ionames=None, robotaccelmult=None, robotspeed=None):
        """Goes through the gripper calibration procedure

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            ionames (list, optional): A list of IO names to read/write
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
        """
        taskparameters = {
            'command': 'CalibrateGripper',
        }
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def StopGripper(self, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, ionames=None, robotaccelmult=None, robotspeed=None):
        """

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            ionames (list, optional): A list of IO names to read/write
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
        """
        taskparameters = {
            'command': 'StopGripper',
        }
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def MoveGripper(self, grippervalues, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotspeed=None, unit='mm'):
        """Moves the chuck of the manipulator to a given value.

        Args:
            grippervalues (list[float]): Target value(s) of the chuck.
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'MoveGripper',
            'grippervalues': grippervalues,
            'unit': unit,
        }
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ExecuteRobotProgram(self, robotProgramName, robotname=None, timeout=10, fireandforget=False, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotspeed=None, toolname=None, unit='mm'):
        """Execute a robot specific program by name

        Args:
            robotProgramName (str):
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'ExecuteRobotProgram',
            'robotProgramName': robotProgramName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SaveScene(self, timeout=10, filename=None, preserveexternalrefs=None, externalref=None, saveclone=None, saveReferenceUriAsHint=None):
        """Saves the current scene to file

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            filename (str, optional): e.g. /tmp/testscene.mujin.dae, if not specified, it will be saved with an auto-generated filename
            preserveexternalrefs (bool, optional): If True, any bodies that are currently being externally referenced from the environment will be saved as external references.
            externalref (str, optional): If '*', then each of the objects will be saved as externally referencing their original filename. Otherwise will force saving specific bodies as external references.
            saveclone: (DEPRECATED) If 1, will save the scenes for all the cloned environments
            saveReferenceUriAsHint (bool, optional): If True, use save the reference uris as referenceUriHint so that webstack does not get confused and deletes content

        Returns:
            The filename the scene is saved to, in a json dictionary, e.g. {'filename': '2013-11-01-17-10-00-UTC.dae'}

        """
        taskparameters = {
            'command': 'SaveScene',
        }
        if externalref is not None:
            taskparameters['externalref'] = externalref
        if filename is not None:
            taskparameters['filename'] = filename
        if preserveexternalrefs is not None:
            taskparameters['preserveexternalrefs'] = preserveexternalrefs
        if saveReferenceUriAsHint is not None:
            taskparameters['saveReferenceUriAsHint'] = saveReferenceUriAsHint
        if saveclone is not None:
            taskparameters['saveclone'] = saveclone
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SaveGripper(self, timeout=10, robotname=None, filename=None, manipname=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, toolname=None, unit='mm'):
        """Separate gripper from a robot in a scene and save it.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotname (str, optional): Name of the robot waiting to extract the hand from.
            filename (str, optional): File name to save on the file system. e.g. /tmp/robotgripper/mujin.dae
            manipname (str, optional): Name of the manipulator.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SaveGripper',
            'unit': unit,
        }
        if filename is not None:
            taskparameters['filename'] = filename
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if manipname is not None:
            taskparameters['manipname'] = manipname
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJointsToJointConfigurationStates(
        self,
        jointConfigurationStates,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startJointConfigurationStates=None,
        envclearance=None,
        timeout=10,
        jointStates=None,
        jointindices=None,
        calibrategripper=None,
        constraintToolDirection=None,
        currentlimitratios=None,
        debuglevel=None,
        departAccel=None,
        departMinimumCompleteRatio=None,
        departOffsetAwayFromGravity=None,
        departOffsetDir=None,
        disablebodies=None,
        dynamicEnvironmentState=None,
        executionConnectingTrajReverseMult=None,
        executionFilterFactor=None,
        executionReverseRecoveryDistance=None,
        filtertraj=None,
        forceTorqueBasedEstimatorParameters=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        gripperInfo=None,
        ignoreGrabbingTarget=None,
        ionames=None,
        jitter=None,
        jittererParameters=None,
        jointthresh=None,
        loadRobotFeedbackLog=None,
        locationCollisionInfos=None,
        maxJitterLinkDist=None,
        maxManipAccel=None,
        moveStraightParams=None,
        pathPlannerParameters=None,
        robotBridgeConnectionInfo=None,
        saveConcatenateTrajectoryLog=None,
        saveFilterTrajectoryLog=None,
        saveRobotFeedbackLog=None,
        savetrajectorylog=None,
        toolname=None,
        trajname=None,
        unit='mm',
    ):
        """Moves the robot to desired joint angles specified in jointStates

        Args:
            jointConfigurationStates:
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startJointConfigurationStates:
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointStates (list, optional): List[{'jointName':str, 'jointValue':float}]
            jointindices (list[int], optional): List of corresponding joint indices, default is range(len(jointvalues))
            calibrategripper (bool, optional):
            constraintToolDirection (list[float], optional):
            currentlimitratios (list[float], optional): The joints' current limit ratios.
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE.
            departAccel (float, optional):
            departMinimumCompleteRatio (float, optional): The ratio of the linear depart motion that needs to be possible for a pick/place to be executed. Pick/place candidate locations that do not allow sufficient space for the depart motion are discarded. Generally between 0.0 and 1.0.
            departOffsetAwayFromGravity (float, optional): The distance to depart vertically upwards after picking/placing. Overridden by departOffsetDir.
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            disablebodies (bool, optional):
            dynamicEnvironmentState (list[dict], optional):
            executionConnectingTrajReverseMult (float, optional): Used for several code paths such as MoveToolLinear, MoveJointsNoDec, MoveToHandPosition. This is passed to robotbridge. If None, robotbridge uses default value internally.
            executionFilterFactor (float, optional):
            executionReverseRecoveryDistance (float, optional): Specifies the reversing distance for trajectories to recover from collision/position error. This is passed to robotbridge. If None, robotbridge uses default internally (most likely 50 mm).
            filtertraj (bool, optional):
            forceTorqueBasedEstimatorParameters (dict, optional): A set of parameters for force-torque based estimation.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            gripperInfo (dict, optional): TODO(felixvd): Check if this really propagates.
            ignoreGrabbingTarget (bool, optional):
            ionames (list, optional): A list of IO names to read/write
            jitter (float, optional):
            jittererParameters:
            jointthresh (float, optional):
            loadRobotFeedbackLog (bool, optional): If True, will tell robotbridge to load the robot feedback log after trajectory ends
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            maxJitterLinkDist (float, optional): mm.
            maxManipAccel (float, optional):
            moveStraightParams (dict, optional): A set of parameters defining how the robot behaves during linear motions.
            pathPlannerParameters:
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            saveConcatenateTrajectoryLog (bool, optional): If True, will save trajectories used for inputs of concatenate trajectory functions
            saveFilterTrajectoryLog (bool, optional): If True, will save trajectories used for filtering, such as SmartFilter
            saveRobotFeedbackLog (bool, optional): If True, will tell robotbridge to save trajectory files
            savetrajectorylog (bool, optional): If True, will save the commanded (input) trajectories before they are executed
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            trajname (str, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'MoveJointsToJointConfigurationStates',
            'execute': execute,
            'goalJointConfigurationStates': jointConfigurationStates,
            'unit': unit,
        }
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if debuglevel is not None:
            taskparameters['debuglevel'] = debuglevel
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if departMinimumCompleteRatio is not None:
            taskparameters['departMinimumCompleteRatio'] = departMinimumCompleteRatio
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if dynamicEnvironmentState is not None:
            taskparameters['dynamicEnvironmentState'] = dynamicEnvironmentState
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if executionConnectingTrajReverseMult is not None:
            taskparameters['executionConnectingTrajReverseMult'] = executionConnectingTrajReverseMult
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if executionReverseRecoveryDistance is not None:
            taskparameters['executionReverseRecoveryDistance'] = executionReverseRecoveryDistance
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if forceTorqueBasedEstimatorParameters is not None:
            taskparameters['forceTorqueBasedEstimatorParameters'] = forceTorqueBasedEstimatorParameters
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        if gripperInfo is not None:
            taskparameters['gripperInfo'] = gripperInfo
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if jittererParameters is not None:
            taskparameters['jittererParameters'] = jittererParameters
        if jointStates is not None:
            taskparameters['jointStates'] = jointStates
        if jointindices is not None:
            taskparameters['jointindices'] = jointindices
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if loadRobotFeedbackLog is not None:
            taskparameters['loadRobotFeedbackLog'] = loadRobotFeedbackLog
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if pathPlannerParameters is not None:
            taskparameters['pathPlannerParameters'] = pathPlannerParameters
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if saveConcatenateTrajectoryLog is not None:
            taskparameters['saveConcatenateTrajectoryLog'] = saveConcatenateTrajectoryLog
        if saveFilterTrajectoryLog is not None:
            taskparameters['saveFilterTrajectoryLog'] = saveFilterTrajectoryLog
        if saveRobotFeedbackLog is not None:
            taskparameters['saveRobotFeedbackLog'] = saveRobotFeedbackLog
        if savetrajectorylog is not None:
            taskparameters['savetrajectorylog'] = savetrajectorylog
        if startJointConfigurationStates is not None:
            taskparameters['startJointConfigurationStates'] = startJointConfigurationStates
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if trajname is not None:
            taskparameters['trajname'] = trajname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJoints(
        self,
        jointvalues,
        jointindices=None,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startvalues=None,
        envclearance=None,
        timeout=10,
        robotProgramName=None,
        goaljoints='None',
        calibrategripper=None,
        constraintToolDirection=None,
        currentlimitratios=None,
        debuglevel=None,
        departAccel=None,
        departMinimumCompleteRatio=None,
        departOffsetAwayFromGravity=None,
        departOffsetDir=None,
        disablebodies=None,
        dynamicEnvironmentState=None,
        executionConnectingTrajReverseMult=None,
        executionFilterFactor=None,
        executionReverseRecoveryDistance=None,
        filtertraj=None,
        forceTorqueBasedEstimatorParameters=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        gripperInfo=None,
        ignoreGrabbingTarget=None,
        ionames=None,
        jitter=None,
        jittererParameters=None,
        jointthresh=None,
        loadRobotFeedbackLog=None,
        locationCollisionInfos=None,
        maxJitterLinkDist=None,
        maxManipAccel=None,
        moveStraightParams=None,
        pathPlannerParameters=None,
        robotBridgeConnectionInfo=None,
        saveConcatenateTrajectoryLog=None,
        saveFilterTrajectoryLog=None,
        saveRobotFeedbackLog=None,
        savetrajectorylog=None,
        toolname=None,
        trajname=None,
        unit='mm',
    ):
        """Moves the robot to desired joint angles specified in jointvalues

        Args:
            jointvalues (list[float]): (DEPRECATED. Use goaljoints) List of joint values to move to.
            jointindices (list[int], optional): List of corresponding joint indices, default is range(len(jointvalues))
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startvalues (list[float], optional): The robot joint values to start the motion from.
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotProgramName (str, optional):
            goaljoints (list[float], optional): List of joint values to move to. (Default: 'None')
            calibrategripper (bool, optional):
            constraintToolDirection (list[float], optional):
            currentlimitratios (list[float], optional): The joints' current limit ratios.
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE.
            departAccel (float, optional):
            departMinimumCompleteRatio (float, optional): The ratio of the linear depart motion that needs to be possible for a pick/place to be executed. Pick/place candidate locations that do not allow sufficient space for the depart motion are discarded. Generally between 0.0 and 1.0.
            departOffsetAwayFromGravity (float, optional): The distance to depart vertically upwards after picking/placing. Overridden by departOffsetDir.
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            disablebodies (bool, optional):
            dynamicEnvironmentState (list[dict], optional):
            executionConnectingTrajReverseMult (float, optional): Used for several code paths such as MoveToolLinear, MoveJointsNoDec, MoveToHandPosition. This is passed to robotbridge. If None, robotbridge uses default value internally.
            executionFilterFactor (float, optional):
            executionReverseRecoveryDistance (float, optional): Specifies the reversing distance for trajectories to recover from collision/position error. This is passed to robotbridge. If None, robotbridge uses default internally (most likely 50 mm).
            filtertraj (bool, optional):
            forceTorqueBasedEstimatorParameters (dict, optional): A set of parameters for force-torque based estimation.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            gripperInfo (dict, optional): TODO(felixvd): Check if this really propagates.
            ignoreGrabbingTarget (bool, optional):
            ionames (list, optional): A list of IO names to read/write
            jitter (float, optional):
            jittererParameters:
            jointthresh (float, optional):
            loadRobotFeedbackLog (bool, optional): If True, will tell robotbridge to load the robot feedback log after trajectory ends
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            maxJitterLinkDist (float, optional): mm.
            maxManipAccel (float, optional):
            moveStraightParams (dict, optional): A set of parameters defining how the robot behaves during linear motions.
            pathPlannerParameters:
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            saveConcatenateTrajectoryLog (bool, optional): If True, will save trajectories used for inputs of concatenate trajectory functions
            saveFilterTrajectoryLog (bool, optional): If True, will save trajectories used for filtering, such as SmartFilter
            saveRobotFeedbackLog (bool, optional): If True, will tell robotbridge to save trajectory files
            savetrajectorylog (bool, optional): If True, will save the commanded (input) trajectories before they are executed
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            trajname (str, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'MoveJoints',
            'execute': execute,
            'unit': unit,
        }
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if debuglevel is not None:
            taskparameters['debuglevel'] = debuglevel
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if departMinimumCompleteRatio is not None:
            taskparameters['departMinimumCompleteRatio'] = departMinimumCompleteRatio
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if dynamicEnvironmentState is not None:
            taskparameters['dynamicEnvironmentState'] = dynamicEnvironmentState
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if executionConnectingTrajReverseMult is not None:
            taskparameters['executionConnectingTrajReverseMult'] = executionConnectingTrajReverseMult
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if executionReverseRecoveryDistance is not None:
            taskparameters['executionReverseRecoveryDistance'] = executionReverseRecoveryDistance
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if forceTorqueBasedEstimatorParameters is not None:
            taskparameters['forceTorqueBasedEstimatorParameters'] = forceTorqueBasedEstimatorParameters
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        taskparameters['goaljoints'] = jointvalues
        if goaljoints is not None:
            taskparameters['goaljoints'] = goaljoints
        if gripperInfo is not None:
            taskparameters['gripperInfo'] = gripperInfo
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if jittererParameters is not None:
            taskparameters['jittererParameters'] = jittererParameters
        if jointindices is None:
            jointindices = range(len(jointvalues))
            log.warn(u'No jointindices specified. Moving joints with default jointindices: %s', jointindices)
        taskparameters['jointindices'] = list(jointindices)
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if loadRobotFeedbackLog is not None:
            taskparameters['loadRobotFeedbackLog'] = loadRobotFeedbackLog
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if pathPlannerParameters is not None:
            taskparameters['pathPlannerParameters'] = pathPlannerParameters
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotProgramName is not None:
            taskparameters['robotProgramName'] = list(robotProgramName)
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if saveConcatenateTrajectoryLog is not None:
            taskparameters['saveConcatenateTrajectoryLog'] = saveConcatenateTrajectoryLog
        if saveFilterTrajectoryLog is not None:
            taskparameters['saveFilterTrajectoryLog'] = saveFilterTrajectoryLog
        if saveRobotFeedbackLog is not None:
            taskparameters['saveRobotFeedbackLog'] = saveRobotFeedbackLog
        if savetrajectorylog is not None:
            taskparameters['savetrajectorylog'] = savetrajectorylog
        if startvalues is not None:
            taskparameters['startvalues'] = list(startvalues)
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if trajname is not None:
            taskparameters['trajname'] = trajname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJointsToPositionConfiguration(
        self,
        positionConfigurationName=None,
        positionConfigurationCandidateNames=None,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startvalues=None,
        envclearance=None,
        timeout=10,
        calibrategripper=None,
        constraintToolDirection=None,
        currentlimitratios=None,
        debuglevel=None,
        departAccel=None,
        departMinimumCompleteRatio=None,
        departOffsetAwayFromGravity=None,
        departOffsetDir=None,
        disablebodies=None,
        dynamicEnvironmentState=None,
        executionConnectingTrajReverseMult=None,
        executionFilterFactor=None,
        executionReverseRecoveryDistance=None,
        filtertraj=None,
        forceTorqueBasedEstimatorParameters=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        gripperInfo=None,
        ignoreGrabbingTarget=None,
        ionames=None,
        jitter=None,
        jittererParameters=None,
        jointthresh=None,
        loadRobotFeedbackLog=None,
        locationCollisionInfos=None,
        maxJitterLinkDist=None,
        maxManipAccel=None,
        moveStraightParams=None,
        pathPlannerParameters=None,
        robotBridgeConnectionInfo=None,
        robotProgramName=None,
        saveConcatenateTrajectoryLog=None,
        saveFilterTrajectoryLog=None,
        saveRobotFeedbackLog=None,
        savetrajectorylog=None,
        startJointConfigurationStates=None,
        toolname=None,
        trajname=None,
        unit='mm',
    ):
        """Moves the robot to desired position configuration specified in positionConfigurationName

        Args:
            positionConfigurationName (str, optional): If specified, the name of position configuration to move to. If it does not exist, will raise an error.
            positionConfigurationCandidateNames (list[str], optional): If specified, goes to the first position that is defined for the robot. If no positions exist, returns without moving the robot.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startvalues (list[float], optional): The robot joint values to start the motion from.
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            calibrategripper (bool, optional):
            constraintToolDirection (list[float], optional):
            currentlimitratios (list[float], optional): The joints' current limit ratios.
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE.
            departAccel (float, optional):
            departMinimumCompleteRatio (float, optional): The ratio of the linear depart motion that needs to be possible for a pick/place to be executed. Pick/place candidate locations that do not allow sufficient space for the depart motion are discarded. Generally between 0.0 and 1.0.
            departOffsetAwayFromGravity (float, optional): The distance to depart vertically upwards after picking/placing. Overridden by departOffsetDir.
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            disablebodies (bool, optional):
            dynamicEnvironmentState (list[dict], optional):
            executionConnectingTrajReverseMult (float, optional): Used for several code paths such as MoveToolLinear, MoveJointsNoDec, MoveToHandPosition. This is passed to robotbridge. If None, robotbridge uses default value internally.
            executionFilterFactor (float, optional):
            executionReverseRecoveryDistance (float, optional): Specifies the reversing distance for trajectories to recover from collision/position error. This is passed to robotbridge. If None, robotbridge uses default internally (most likely 50 mm).
            filtertraj (bool, optional):
            forceTorqueBasedEstimatorParameters (dict, optional): A set of parameters for force-torque based estimation.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            gripperInfo (dict, optional): TODO(felixvd): Check if this really propagates.
            ignoreGrabbingTarget (bool, optional):
            ionames (list, optional): A list of IO names to read/write
            jitter (float, optional):
            jittererParameters:
            jointthresh (float, optional):
            loadRobotFeedbackLog (bool, optional): If True, will tell robotbridge to load the robot feedback log after trajectory ends
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            maxJitterLinkDist (float, optional): mm.
            maxManipAccel (float, optional):
            moveStraightParams (dict, optional): A set of parameters defining how the robot behaves during linear motions.
            pathPlannerParameters:
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotProgramName (str, optional):
            saveConcatenateTrajectoryLog (bool, optional): If True, will save trajectories used for inputs of concatenate trajectory functions
            saveFilterTrajectoryLog (bool, optional): If True, will save trajectories used for filtering, such as SmartFilter
            saveRobotFeedbackLog (bool, optional): If True, will tell robotbridge to save trajectory files
            savetrajectorylog (bool, optional): If True, will save the commanded (input) trajectories before they are executed
            startJointConfigurationStates (list[dict], optional): List of dicts for each joint.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            trajname (str, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')

        Returns:
            Dictionary with keys goalPositionName and values goalConfiguration

        """
        taskparameters = {
            'command': 'MoveJointsToPositionConfiguration',
            'execute': execute,
            'unit': unit,
        }
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if debuglevel is not None:
            taskparameters['debuglevel'] = debuglevel
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if departMinimumCompleteRatio is not None:
            taskparameters['departMinimumCompleteRatio'] = departMinimumCompleteRatio
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if dynamicEnvironmentState is not None:
            taskparameters['dynamicEnvironmentState'] = dynamicEnvironmentState
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if executionConnectingTrajReverseMult is not None:
            taskparameters['executionConnectingTrajReverseMult'] = executionConnectingTrajReverseMult
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if executionReverseRecoveryDistance is not None:
            taskparameters['executionReverseRecoveryDistance'] = executionReverseRecoveryDistance
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if forceTorqueBasedEstimatorParameters is not None:
            taskparameters['forceTorqueBasedEstimatorParameters'] = forceTorqueBasedEstimatorParameters
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        if gripperInfo is not None:
            taskparameters['gripperInfo'] = gripperInfo
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if jittererParameters is not None:
            taskparameters['jittererParameters'] = jittererParameters
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if loadRobotFeedbackLog is not None:
            taskparameters['loadRobotFeedbackLog'] = loadRobotFeedbackLog
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if pathPlannerParameters is not None:
            taskparameters['pathPlannerParameters'] = pathPlannerParameters
        if positionConfigurationCandidateNames is not None:
            taskparameters['positionConfigurationCandidateNames'] = positionConfigurationCandidateNames
        if positionConfigurationName is not None:
            taskparameters['positionConfigurationName'] = positionConfigurationName
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotProgramName is not None:
            taskparameters['robotProgramName'] = robotProgramName
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if saveConcatenateTrajectoryLog is not None:
            taskparameters['saveConcatenateTrajectoryLog'] = saveConcatenateTrajectoryLog
        if saveFilterTrajectoryLog is not None:
            taskparameters['saveFilterTrajectoryLog'] = saveFilterTrajectoryLog
        if saveRobotFeedbackLog is not None:
            taskparameters['saveRobotFeedbackLog'] = saveRobotFeedbackLog
        if savetrajectorylog is not None:
            taskparameters['savetrajectorylog'] = savetrajectorylog
        if startJointConfigurationStates is not None:
            taskparameters['startJointConfigurationStates'] = startJointConfigurationStates
        if startvalues is not None:
            taskparameters['startvalues'] = list(startvalues)
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if trajname is not None:
            taskparameters['trajname'] = trajname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetRobotBridgeIOVariables(self, ioname=None, ionames=None, robotname=None, timeout=10, locationCollisionInfos=None, robotBridgeConnectionInfo=None, toolname=None, unit='mm'):
        """Returns the data of the IO in ASCII hex as a string

        Args:
            ioname (str, optional): One IO name to read
            ionames (list, optional): A list of the IO names to read
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'GetRobotBridgeIOVariables',
            'unit': unit,
        }
        if ioname is not None and len(ioname) > 0:
            taskparameters['ioname'] = ioname
        if ionames is not None and len(ionames) > 0:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgeIOVariables(self, iovalues, robotname=None, timeout=10, forceasync=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, toolname=None, unit='mm'):
        """Sets a set of IO variables in the robot bridge.

        This should not lock self.env since it can happen during the runtime of a task and lock out other functions waiting in the queue.

        Args:
            iovalues:
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            forceasync (bool, optional):
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetRobotBridgeIOVariables',
            'iovalues': list(iovalues),
            'unit': unit,
        }
        if forceasync is not None:
            taskparameters['forceasync'] = forceasync
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeIkParamPosition(self, name, robotname=None, timeout=10, jointvalues=None, toolname=None, unit='mm'):
        """Given the name of a Kinbody, computes the manipulator (TCP) position in the kinbody frame to generate values for an IKParameterization.

        Args:
            name (str): Name of the Kinbody (the robot).
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointvalues (list[float], optional): If given, the robot's joints are set to these values before calculating the manipulator (TCP) position. If not set, uses the current values.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')

        Returns:
            A dictionary with the structure:

            translation (list[float]): List of x,y,z values of the object in millimeters.
            quaternion (list[float]): List specifying the quaternion in w,x,y,z format, e.g. [1,0,0,0].
            direction (list): The global direction of the manipulator (assuming that the direction of the manipulator is the positive Z-axis).
            angleXZ (float)
            angleYX (float)
            angleZY (float)
            angleX (float)
            angleY (float)
            angleZ (float)
        """
        taskparameters = {
            'command': 'ComputeIkParamPosition',
            'name': name,
            'unit': unit,
        }
        if jointvalues is not None:
            taskparameters['jointvalues'] = jointvalues
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeIKFromParameters(self, toolname=None, timeout=10, applyapproachoffset=None, disabletarget=None, filteroptions=None, filteroptionslist=None, freeinc=None, freeincvalue=None, graspsetname=None, ikparamnames=None, inPlaneAngleDeviation=None, limit=None, outOfPlaneAngleDeviation=None, randomBoxInfo=None, returnClosestToCurrent=None, robotname=None, searchfreeparams=None, targetname=None, unit='mm', useSolutionIndices=None):
        """

        Args:
            toolname (str, optional): Tool name
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            applyapproachoffset (bool, optional):
            disabletarget (bool, optional):
            filteroptions (int, optional): OpenRAVE IkFilterOptions bitmask. By default this is 1, which means all collisions are checked
            filteroptionslist (list[str], optional): A list of filter option strings. Can be: CheckEnvCollisions, IgnoreCustomFilters, IgnoreEndEffectorCollisions, IgnoreEndEffectorEnvCollisions, IgnoreEndEffectorSelfCollisions, IgnoreJointLimits, IgnoreSelfCollisions. Overrides filteroptions.
            freeinc (float, optional): (DEPRECATED) The discretization of the free joints of the robot when computing ik.
            freeincvalue (float, optional): The discretization of the free joints of the robot when computing ik.
            graspsetname (str, optional): Name of the grasp set to use
            ikparamnames (list[str], optional): If graspset does not exist, use the ikparamnames to initialize the grasp.
            inPlaneAngleDeviation (float, optional):
            limit (float, optional): Number of solutions to return
            outOfPlaneAngleDeviation (float, optional):
            randomBoxInfo (dict, optional): Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True). Keys: usefaces, dictFacePriorities, boxDirAngle, toolTranslationOffsets
            returnClosestToCurrent (bool, optional):
            robotname (str, optional): Name of the robot
            searchfreeparams (bool, optional):
            targetname (str, optional): Name of the target object
            unit (str, optional): The unit of the given values. (Default: 'mm')
            useSolutionIndices (bool, optional):

        Returns:
            A dictionary with field 'solutions': array of IK solutions (each of which is an array of DOF values), sorted by minimum travel distance and truncated to match the limit
            If no solutions found, the field 'errors' will contain reasons for the failure.

        """
        taskparameters = {
            'command': 'ComputeIKFromParameters',
            'unit': unit,
        }
        if applyapproachoffset is not None:
            taskparameters['applyapproachoffset'] = applyapproachoffset
        if disabletarget is not None:
            taskparameters['disabletarget'] = disabletarget
        if filteroptions is not None:
            taskparameters['filteroptions'] = filteroptions
        if filteroptionslist is not None:
            taskparameters['filteroptionslist'] = filteroptionslist
        if freeinc is not None:
            taskparameters['freeinc'] = freeinc
        if freeincvalue is not None:
            taskparameters['freeincvalue'] = freeincvalue
        if graspsetname is not None:
            taskparameters['graspsetname'] = graspsetname
        if ikparamnames is not None:
            taskparameters['ikparamnames'] = ikparamnames
        if inPlaneAngleDeviation is not None:
            taskparameters['inPlaneAngleDeviation'] = inPlaneAngleDeviation
        if limit is not None:
            taskparameters['limit'] = limit
        if outOfPlaneAngleDeviation is not None:
            taskparameters['outOfPlaneAngleDeviation'] = outOfPlaneAngleDeviation
        if randomBoxInfo is not None:
            taskparameters['randomBoxInfo'] = randomBoxInfo
        if returnClosestToCurrent is not None:
            taskparameters['returnClosestToCurrent'] = returnClosestToCurrent
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if searchfreeparams is not None:
            taskparameters['searchfreeparams'] = searchfreeparams
        if targetname is not None:
            taskparameters['targetname'] = targetname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if useSolutionIndices is not None:
            taskparameters['useSolutionIndices'] = useSolutionIndices
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ShutdownRobotBridge(self, timeout=10, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'ShutdownRobotBridge',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetRobotBridgeState(self, timeout=10, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'GetRobotBridgeState',
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ClearRobotBridgeError(self, timeout=10, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'ClearRobotBridgeError',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgePause(self, timeout=10, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetRobotBridgePause',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgeResume(self, timeout=10, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetRobotBridgeResume',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetJogModeVelocities(self, movejointsigns, robotname=None, toolname=None, robotspeed=None, robotaccelmult=None, canJogInCheckMode=None, timeout=1, fireandforget=False, jogtype=None, checkSelfCollisionWhileJogging=None, force=None, locationCollisionInfos=None, plotDirection=None, robotBridgeConnectionInfo=None, robotJogParameters=None, simulationtimestep=None, unit='mm'):
        """

        Args:
            movejointsigns (list[float]): Joint signs used for jogging. If less than the number of joints, will be padded with zeros.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] setting the percentage of robot acceleration to move at
            canJogInCheckMode (bool, optional): If True, then allow jogging even if in check mode. (Default: False)
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            jogtype (str, optional): One of 'joints', 'world', 'robot', 'tool'. (DEPRECATED: set this as a field in robotJogParameters instead)
            checkSelfCollisionWhileJogging (bool, optional):
            force (bool, optional): If true, forces the velocities to be set.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            plotDirection (bool, optional): If True, plot the direction.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotJogParameters (dict, optional): A dictionary. Includes field 'jogtype' (One of 'joints', 'world', 'robot', 'tool').
            simulationtimestep (float, optional): Time step of the simulation.
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetJogModeVelocities',
            'movejointsigns': movejointsigns,
            'unit': unit,
        }
        if canJogInCheckMode is not None:
            taskparameters['canJogInCheckMode'] = canJogInCheckMode
        if checkSelfCollisionWhileJogging is not None:
            taskparameters['checkSelfCollisionWhileJogging'] = checkSelfCollisionWhileJogging
        if force is not None:
            taskparameters['force'] = force
        if jogtype is not None:
            taskparameters['jogtype'] = jogtype
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if plotDirection is not None:
            taskparameters['plotDirection'] = plotDirection
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotJogParameters is not None:
            taskparameters['robotJogParameters'] = robotJogParameters
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if simulationtimestep is not None:
            taskparameters['simulationtimestep'] = simulationtimestep
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def EndJogMode(self, timeout=1, fireandforget=False, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'EndJogMode',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeServoOn(self, servoon, robotname=None, timeout=3, fireandforget=False):
        """

        Args:
            servoon (bool): If True, turns servo on.
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeServoOn',
            'isservoon': servoon,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeLockMode(self, islockmode, robotname=None, timeout=3, fireandforget=False):
        """

        Args:
            islockmode (bool): If True, turns on Lock Mode. During Lock Mode, all communication with the physical robot is turned off and the hardware will not move.
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeLockMode',
            'islockmode': islockmode,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetSafetyFault(self, timeout=3, fireandforget=False):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetSafetyFault',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeControlMode(self, controlMode, timeout=3, fireandforget=False):
        """

        Args:
            controlMode (str): The control mode to use, e.g. "Manual".
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeControlMode',
            'controlMode': controlMode,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetDynamicObjects(self, timeout=1):
        """Get a list of dynamically added objects in the scene, from vision detection and physics simulation.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
        """
        taskparameters = {
            'command': 'GetDynamicObjects',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeRobotConfigsForGraspVisualization(self, targetname, graspname, robotname=None, toolname=None, unit='mm', timeout=10, approachoffset=None, departoffsetdir=None, departoffsetintool=None, shadowrobotname=None, shadowrobottoolname=None):
        """Returns robot configs for grasp visualization

        Args:
            targetname (str): Target object's name.
            graspname (str): Name of the grasp for which to visualize grasps.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            approachoffset (float, optional):
            departoffsetdir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departoffsetintool (list[float], optional):
            shadowrobotname (str, optional):
            shadowrobottoolname (str, optional):
        """
        taskparameters = {
            'command': 'ComputeRobotConfigsForGraspVisualization',
            'graspname': graspname,
            'targetname': targetname,
            'unit': unit,
        }
        if approachoffset is not None:
            taskparameters['approachoffset'] = approachoffset
        if departoffsetdir is not None:
            taskparameters['departoffsetdir'] = departoffsetdir
        if departoffsetintool is not None:
            taskparameters['departoffsetintool'] = departoffsetintool
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if shadowrobotname is not None:
            taskparameters['shadowrobotname'] = shadowrobotname
        if shadowrobottoolname is not None:
            taskparameters['shadowrobottoolname'] = shadowrobottoolname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ResetCacheTemplates(self, timeout=1, fireandforget=False):
        """Resets any cached templates

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetCacheTemplates',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeExternalIOPublishing(self, enable, timeout=2, fireandforget=False):
        """Enables publishing collision data to the robotbridge

        Args:
            enable (bool): If True, collision data will be published to robotbridge.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 2)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeExternalIOPublishing',
            'enable': bool(enable),
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def RestoreSceneInitialState(self, timeout=1, preserverobotdofvalues=1):
        """Restores the scene to the state on the filesystem

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            preserverobotdofvalues (bool, optional): (Default: 1)
        """
        taskparameters = {
            'command': 'RestoreSceneInitialState',
            'preserverobotdofvalues': preserverobotdofvalues,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningStepTest(self, jointName, amplitude, timeout=10):
        """Runs step response test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'RunMotorControlTuningStepTest',
            'amplitude': amplitude,
            'jointName': jointName,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningMaximulLengthSequence(self, jointName, amplitude, timeout=10, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """Runs maximum length sequence test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'RunMotorControlTuningMaximulLengthSequence',
            'amplitude': amplitude,
            'jointName': jointName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningDecayingChirp(self, jointName, amplitude, freqMax, timeout=120, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """runs chirp test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            freqMax (float): The maximum frequency in Hz
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 120)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'RunMotorControlTuningDecayingChirp',
            'amplitude': amplitude,
            'freqMax': freqMax,
            'jointName': jointName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningGaussianImpulse(self, jointName, amplitude, timeout=20, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """Runs Gaussian Impulse test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 20)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'RunMotorControlTuningGaussianImpulse',
            'amplitude': amplitude,
            'jointName': jointName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningBangBangResponse(self, jointName, amplitude, timeout=60, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """Runs bangbang trajectory in acceleration or jerk space and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 60)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'RunMotorControlTuningBangBangResponse',
            'amplitude': amplitude,
            'jointName': jointName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunDynamicsIdentificationTest(self, timeout, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float): Time in seconds after which the command is assumed to have failed. (Default: 4.0)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'RunDynamicsIdentificationTest',
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetTimeToRunDynamicsIdentificationTest(self, timeout=10, jointName=None, minJointAngle=None, maxJointAngle=None, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointName (str, optional): The name of the joint.
            minJointAngle (float, optional): The joint angle to start the dynamics identification test at.
            maxJointAngle (float, optional): The joint angle to finish the dynamics identification test at.
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'GetTimeToRunDynamicsIdentificationTest',
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jointName is not None:
            taskparameters['jointName'] = jointName
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if maxJointAngle is not None:
            taskparameters['maxJointAngle'] = maxJointAngle
        if minJointAngle is not None:
            taskparameters['minJointAngle'] = minJointAngle
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def CalculateTestRangeFromCollision(self, timeout=10, jointName=None, unit='mm', envclearance=None, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointName (str, optional): The name of the joint.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            envclearance (float, optional): Environment clearance in millimeters.
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
        """
        taskparameters = {
            'command': 'CalculateTestRangeFromCollision',
            'unit': unit,
        }
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jointName is not None:
            taskparameters['jointName'] = jointName
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameterSchema(self, timeout=10):
        """Gets motor control parameter schema

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'GetMotorControlParameterSchema',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameter(self, jointName, parameterName, timeout=10, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """Gets motor control parameters as a name-value dict, e.g.: {'J1':{'KP':1}, 'J2':{'KV':2}}

        Args:
            jointName (str):
            parameterName (str):
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'GetMotorControlParameter',
            'jointName': jointName,
            'parameterName': parameterName,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameters(self, timeout=10):
        """Gets cached motor control parameters as name-value dict

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'GetMotorControlParameters',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetMotorControlParameter(self, jointName, parameterName, parameterValue, timeout=10, ionames=None, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotaccelmult=None, robotname=None, robotspeed=None, toolname=None, unit='mm'):
        """Sets motor control parameter

        Args:
            jointName (str): The name of the joint.
            parameterName (str): The name of the parameter to set.
            parameterValue: The value to assign to the parameter.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ionames (list, optional): A list of IO names to read/write
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetMotorControlParameter',
            'jointName': jointName,
            'parameterName': parameterName,
            'parameterValue': parameterValue,
            'unit': unit,
        }
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def IsProfilingRunning(self, timeout=10):
        """Queries if profiling is running on planning

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'IsProfilingRunning',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StartProfiling(self, clocktype='cpu', timeout=10):
        """Start profiling planning

        Args:
            clocktype (str, optional): (Default: 'cpu')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'StartProfiling',
            'clocktype': clocktype,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StopProfiling(self, timeout=10):
        """Stop profiling planning

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'StopProfiling',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ReplaceBodies(self, bodieslist, timeout=10, replaceInfos=None, testLocationName=None, testLocationContainerId=None, removeNamePrefixes=None, removeLocationNames=None, doRemoveOnlyDynamic=None, unit='mm'):
        """Replaces bodies in the environment with new uris

        Args:
            bodieslist:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            replaceInfos (list, optional): list of dicts with keys: name, uri, containerDynamicProperties
            testLocationName (str, optional): If specified, will test if the container in this location matches testLocationContainerId, and only execute the replace if it matches and testLocationContainerId is not empty.
            testLocationContainerId (str, optional): containerId used for testing logic with testLocationName
            removeNamePrefixes (list[str], optional): Names of prefixes to match with when removing items
            removeLocationNames (list[str], optional):
            doRemoveOnlyDynamic (bool, optional): If True, removes objects that were added through dynamic means such as UpdateObjects/UpdateEnvironmentState. Default: False
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'ReplaceBodies',
            'bodieslist': bodieslist,
            'unit': unit,
        }
        if doRemoveOnlyDynamic is not None:
            taskparameters['doRemoveOnlyDynamic'] = doRemoveOnlyDynamic
        if removeLocationNames is not None:
            taskparameters['removeLocationNames'] = removeLocationNames
        if removeNamePrefixes is not None:
            taskparameters['removeNamePrefixes'] = removeNamePrefixes
        taskparameters['replaceInfos'] = bodieslist
        if replaceInfos is not None:
            taskparameters['replaceInfos'] = replaceInfos
        if testLocationContainerId is not None:
            taskparameters['testLocationContainerId'] = testLocationContainerId
        if testLocationName is not None:
            taskparameters['testLocationName'] = testLocationName
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetState(self, timeout=10.0, fireandforget=False, locationCollisionInfos=None, robotBridgeConnectionInfo=None, robotname=None, toolname=None, unit='mm'):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10.0)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'GetState',
            'unit': unit,
        }
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def EnsureSyncWithRobotBridge(self, syncTimeStampUS, timeout=10, fireandforget=False):
        """Ensures that planning has synchronized with robotbridge data that is newer than syncTimeStampUS

        Args:
            syncTimeStampUS: us (microseconds, linux time) of the timestamp
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'EnsureSyncWithRobotBridge',
            'syncTimeStampUS': syncTimeStampUS,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetCachedRobotConfigurationState(self, timeout=10, fireandforget=False):
        """Resets cached robot configuration (position of the robot) in the planning slave received from slave notification. Need to perform every time robot moved not from the task slaves.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetCachedRobotConfigurationState',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)



# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
