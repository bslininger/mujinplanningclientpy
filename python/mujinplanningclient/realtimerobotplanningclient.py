# Copyright (C) 2012-2023 Mujin, Inc.

# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

from . import json
from . import planningclient

import logging
log = logging.getLogger(__name__)

class RealtimeRobotPlanningClient(planningclient.PlanningClient):
    """Mujin planning client for the RealtimeRobot task"""
    _robotname = None  # Optional name of the robot selected
    _robotspeed = None  # Speed of the robot, e.g. 0.4
    _robotaccelmult = None  # Current robot accel mult
    _envclearance = None  # Environment clearance in millimeters, e.g. 20
    _robotBridgeConnectionInfo = None  # dict holding the connection info for the robot bridge.
    

    def __init__(
        self,
        robotname='',
        robotspeed=None,
        robotaccelmult=None,
        envclearance=10.0,
        robotBridgeConnectionInfo=None,
        scenepk='',
        controllerip='',
        controllerusername='',
        controllerpassword='',
        controllerurl='',
        tasktype='realtimerobot',
        slaverequestid=None,
        taskzmqport=7110,
        taskheartbeatport=7111,
        taskheartbeattimeout=7.0,
        ctx=None,
        author=None,
        **ignoredArgs  # Additional keyword args are not used, but allowed for easy initialization from a dictionary
    ):
        """Connects to the Mujin controller, initializes RealtimeRobot task and sets up parameters

        Args:
            robotname (str, optional): Name of the robot, e.g. VP-5243I
            robotspeed (float, optional): Speed of the robot, e.g. 0.4
            robotaccelmult (float, optional): Optional multiplier for the robot acceleration.
            envclearance (str, optional): Environment clearance in millimeter, e.g. 20
            robotBridgeConnectionInfo (str, optional): dict holding the connection info for the robot bridge.
            scenepk (str, optional): Primary key (pk) of the scene, e.g. irex_demo.mujin.dae
            controllerip (str): IP or hostname of the mujin controller, e.g. 172.17.0.2 or controller123
            controllerusername (str): Username for the Mujin controller, e.g. testuser
            controllerpassword (str): Password for the Mujin controller
            controllerurl (str, optional): (Deprecated. Use controllerip instead) URL of the mujin controller, e.g. http://controller14.
            tasktype (str, optional): Type of the task, e.g. 'binpicking', 'handeyecalibration', 'itlrealtimeplanning3'. Default: realtimerobot
            taskzmqport (int, optional): Port of the task's ZMQ server, e.g. 7110
            taskheartbeatport (int, optional): Port of the task's ZMQ server's heartbeat publisher, e.g. 7111
            taskheartbeattimeout (float, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
            ctx (zmq.Context, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
        """
        self._robotname = robotname
        self._robotspeed = robotspeed
        self._robotaccelmult = robotaccelmult
        self._envclearance = envclearance
        self._robotBridgeConnectionInfo = robotBridgeConnectionInfo
        super(RealtimeRobotPlanningClient, self).__init__(taskzmqport=taskzmqport, taskheartbeatport=taskheartbeatport, taskheartbeattimeout=taskheartbeattimeout, tasktype=tasktype, scenepk=scenepk, ctx=ctx, slaverequestid=slaverequestid, controllerurl=controllerurl, controllerusername=controllerusername, controllerpassword=controllerpassword, author=author)

    def GetRobotConnectionInfo(self):
        """ """
        return self._robotBridgeConnectionInfo

    def SetRobotConnectionInfo(self, robotBridgeConnectionInfo):
        """

        Args:
            robotBridgeConnectionInfo:
        """
        self._robotBridgeConnectionInfo = robotBridgeConnectionInfo

    def GetRobotName(self):
        """ """
        return self._robotname

    def SetRobotName(self, robotname):
        """

        Args:
            robotname (str):
        """
        self._robotname = robotname

    def SetRobotSpeed(self, robotspeed):
        """

        Args:
            robotspeed:
        """
        self._robotspeed = robotspeed

    def SetRobotAccelMult(self, robotaccelmult):
        """

        Args:
            robotaccelmult:
        """
        self._robotaccelmult = robotaccelmult

    def ExecuteCommand(self, taskparameters, robotname=None, toolname=None, robotspeed=None, robotaccelmult=None, envclearance=None, timeout=10, fireandforget=False, respawnopts=None):
        """Wrapper to ExecuteCommand with robot info specified in taskparameters.

        Executes a command in the task.

        Args:
            taskparameters (dict): Specifies the arguments of the task/command being called.
            robotname (str, optional): Name of the robot
            robotaccelmult (float, optional):
            envclearance (float, optional):
            respawnopts (optional):
            toolname (str, optional): Name of the manipulator.
            timeout (float, optional):  (Default: 10)
            fireandforget (bool, optional):  (Default: False)
            robotspeed (float, optional):

        Returns:
            dict: Contains:
                - robottype (str): robot type
                - currentjointvalues (list[float]): current joint values, vector length = DOF
                - elapsedtime (float): elapsed time in seconds
                - numpoints (int): the number of points
                - error (dict): optional error info
                - desc (str): error message
                - type (str): error type
                - errorcode (str): error code
        """
        if robotname is None:
            robotname = self._robotname

        # caller wants to use a different tool
        if toolname is not None:
            # set at the first level
            taskparameters['toolname'] = toolname

        if robotname is not None:
            taskparameters['robotname'] = robotname

        if 'robotspeed' not in taskparameters:
            if robotspeed is None:
                robotspeed = self._robotspeed
            if robotspeed is not None:
                taskparameters['robotspeed'] = robotspeed

        if 'robotaccelmult' not in taskparameters:
            if robotaccelmult is None:
                robotaccelmult = self._robotaccelmult
            if robotaccelmult is not None:
                taskparameters['robotaccelmult'] = robotaccelmult

        if self._robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = self._robotBridgeConnectionInfo

        if 'envclearance' not in taskparameters or taskparameters['envclearance'] is None:
            if envclearance is None:
                envclearance = self._envclearance
            if envclearance is not None:
                taskparameters['envclearance'] = envclearance

        return super(RealtimeRobotPlanningClient, self).ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget, respawnopts=respawnopts)
    
    #
    # Generated commands
    #

    # ============== Auto-generated code starts here

    def GetJointValues(self, timeout=10, executetimeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """Gets the current robot joint values

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            executetimeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.

        Returns:
            Current joint values in a json dictionary with key currentjointvalues and value [0,0,0,0,0,0]

        """
        taskparameters = {
            'command': 'GetJointValues',
            'unit': unit,
            'executetimeout': executetimeout,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveToolLinear(
        self,
        goaltype,
        goals,
        toolname=None,
        timeout=10,
        robotspeed=None,
        workmaxdeviationangle=None,
        workspeed=None,
        workaccel=None,
        worksteplength=None,
        plannername=None,
        workminimumcompletetime=None,
        workminimumcompleteratio=None,
        numspeedcandidates=None,
        workignorefirstcollisionee=None,
        workignorelastcollisionee=None,
        workignorefirstcollision=None,
        unit='mm',
        robotBridgeConnectionInfo=None,
        locationCollisionInfos=None,
        robotaccelmult=None,
        ionames=None,
        ignoreGrabbingTarget=None,
        currentlimitratios=None,
        instobjectname=None,
        ikparamname=None,
        execute=None,
        moveStraightParams=None,
        **ignoredArgs
    ):
        """Moves the tool linearly in cartesian (3D) space.

        Args:
            goaltype (str): Type of the goal, e.g. translationdirection5d
            goals (list[float]): Flat list of goals, e.g. two 5D ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            toolname (str, optional): Tool name(s)
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            workmaxdeviationangle (float, optional): How much the tool tip can rotationally deviate from the linear path. In deg.
            workspeed (list[float], optional): [anglespeed, transspeed] in deg/s and mm/s
            workaccel (list[float], optional): [angleaccel, transaccel] in deg/s^2 and mm/s^2
            worksteplength (float, optional): Discretization for planning MoveHandStraight, in seconds.
            plannername (str, optional):
            workminimumcompletetime (float, optional): (DEPRECATED, UNUSED) Set to trajduration - 0.016s. EMU_MUJIN example requires at least this much
            workminimumcompleteratio (float, optional): (DEPRECATED, UNUSED) In case the duration of the trajectory is now known, can specify in terms of [0,1]. 1 is complete everything.
            numspeedcandidates (int, optional): If speed/accel are not specified, the number of candiates to consider
            workignorefirstcollisionee (float, optional): time, necessary in case initial is in collision, has to be multiples of step length?
            workignorelastcollisionee (float, optional): time, necessary in case goal is in collision, has to be multiples of step length?
            workignorefirstcollision (float, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
            ignoreGrabbingTarget (bool, optional):
            currentlimitratios (list[float], optional): The joints' current limt ratios.
            instobjectname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ikparamname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            execute:
            moveStraightParams (dict, optional): Parameters used for linear movement like grasp approach, grasp depart, etc.
        """
        taskparameters = {
            'command': 'MoveToolLinear',
            'unit': unit,
            'goaltype': goaltype,
            'goals': goals,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if instobjectname is not None:
            taskparameters['instobjectname'] = instobjectname
        if ikparamname is not None:
            taskparameters['ikparamname'] = ikparamname
        if execute is not None:
            taskparameters['execute'] = execute
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if workmaxdeviationangle is not None:
            taskparameters['workmaxdeviationangle'] = workmaxdeviationangle
        if workspeed is not None:
            taskparameters['workspeed'] = workspeed
        if workaccel is not None:
            taskparameters['workaccel'] = workaccel
        if worksteplength is not None:
            taskparameters['worksteplength'] = worksteplength
        if plannername is not None:
            taskparameters['plannername'] = plannername
        if workminimumcompletetime is not None:
            taskparameters['workminimumcompletetime'] = workminimumcompletetime
        if workminimumcompleteratio is not None:
            taskparameters['workminimumcompleteratio'] = workminimumcompleteratio
        if numspeedcandidates is not None:
            taskparameters['numspeedcandidates'] = numspeedcandidates
        if workignorefirstcollisionee is not None:
            taskparameters['workignorefirstcollisionee'] = workignorefirstcollisionee
        if workignorelastcollisionee is not None:
            taskparameters['workignorelastcollisionee'] = workignorelastcollisionee
        if workignorefirstcollision is not None:
            taskparameters['workignorefirstcollision'] = workignorefirstcollision
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveToHandPosition(
        self,
        goaltype,
        goals,
        toolname=None,
        envclearance=None,
        closegripper=0,
        robotspeed=None,
        robotaccelmult=None,
        timeout=10,
        unit='mm',
        robotBridgeConnectionInfo=None,
        locationCollisionInfos=None,
        ionames=None,
        minimumgoalpaths=None,
        chuckgripper=None,
        currentlimitratios=None,
        instobjectname=None,
        ikparamname=None,
        ikparamoffset=None,
        pathPlannerParameters=None,
        smootherParameters=None,
        ignoreGrabbingTarget=None,
        jitter=None,
        maxJitterLinkDist=None,
        execute=None,
        filtertraj=None,
        executionFilterFactor=None,
        departOffsetDir=None,
        departOffsetAwayFromGravity=None,
        departAccel=None,
        moveStraightParams=None,
        **ignoredArgs
    ):
        """Computes the inverse kinematics and moves the manipulator to any one of the goals specified.

        Args:
            goaltype (str): Type of the goal, e.g. translationdirection5d
            goals (list[float]): Flat list of goals, e.g. two 5d ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            envclearance (float, optional): Environment clearance in millimeters.
            closegripper (bool, optional): (DEPRECATED) Whether to close gripper once the goal is reached. (Default: 0)
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            ionames (list, optional): A list of IO names to read/write
            minimumgoalpaths (int, optional): Number of solutions the planner must provide before it is allowed to finish.
            chuckgripper (bool, optional):
            currentlimitratios (list[float], optional): The joints' current limt ratios.
            instobjectname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ikparamname (str, optional): If goaltype is not set and both instobjectname and ikparamname are set, use ikparamname of instobjectname as target position.
            ikparamoffset (list[float], optional):
            pathPlannerParameters:
            smootherParameters:
            ignoreGrabbingTarget (bool, optional):
            jitter (float, optional):
            maxJitterLinkDist:
            execute:
            filtertraj (bool, optional):
            executionFilterFactor (float, optional):
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departOffsetAwayFromGravity (float, optional): Overridden by departOffsetDir
            departAccel (float, optional):
            moveStraightParams (dict, optional): Parameters used for linear movement like grasp approach, grasp depart, etc.
        """
        taskparameters = {
            'command': 'MoveToHandPosition',
            'unit': unit,
            'goaltype': goaltype,
            'goals': goals,
            'closegripper': closegripper,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if minimumgoalpaths is not None:
            taskparameters['minimumgoalpaths'] = minimumgoalpaths
        if chuckgripper is not None:
            taskparameters['chuckgripper'] = chuckgripper
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if instobjectname is not None:
            taskparameters['instobjectname'] = instobjectname
        if ikparamname is not None:
            taskparameters['ikparamname'] = ikparamname
        if ikparamoffset is not None:
            taskparameters['ikparamoffset'] = ikparamoffset
        if pathPlannerParameters is not None:
            taskparameters['pathPlannerParameters'] = pathPlannerParameters
        if smootherParameters is not None:
            taskparameters['smootherParameters'] = smootherParameters
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if execute is not None:
            taskparameters['execute'] = execute
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if moveStraightParams is not None:
            taskparameters['moveStraightParams'] = moveStraightParams
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def UpdateObjects(
        self,
        envstate,
        targetname=None,
        state=None,
        unit='mm',
        timeout=10,
        object_uri=None,
        callerid=None,
        detectionResultState=None,
        targetUpdateNamePrefix=None,
        cameranames=None,
        countOverlappingPoints=None,
        overlapUpAxis=None,
        zthresholdmult=None,
        addUnpickableRegionAcrossShortEdgeDist=None,
        sizeRoundUp=None,
        sizePrecisionXYZ=None,
        points=None,
        pointsize=None,
        pointcloudid=None,
        locationName=None,
        containerName=None,
        locationContainerId=None,
        isFromStateSlaveNotify=None,
        imageStartTimeStampMS=None,
        imageEndTimeStampMS=None,
        belowBoxOverlap=0,
        ignoreOverlapPointsFromWall=0,
        ignoreOverlapPointsFromNearbyTargets=0,
        castPointCloudShadowFromCamera=None,
        pointsProjectedDirection=None,
        randomBoxOrigin=None,
        rollStepDegree=90,
        clampToContainer=None,
        medianFilterHalfSize=None,
        useEmptyRegionForCropping=None,
        cropContainerMarginsXYZXYZ=None,
        ioSignalsInfo=None,
        addPointOffsetInfo=None,
        **ignoredArgs
    ):
        """Updates objects in the scene with the envstate

        Args:
            envstate: A list of dictionaries for each instance object in world frame. Quaternion is specified in w,x,y,z order. e.g. [{'name': 'target_0', 'translation_': [1,2,3], 'quat_': [1,0,0,0], 'object_uri':'mujin:/asdfas.mujin.dae'}, {'name': 'target_1', 'translation_': [2,2,3], 'quat_': [1,0,0,0]}]
            targetname (str, optional): Name of the target object
            state (dict, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            object_uri (str, optional): Same as objectname, but in a Mujin URI format, e.g.: mujin:/OBJECTNAME.mujin.dae
            callerid (str, optional): The name of the caller (only used internally)
            detectionResultState (dict, optional): Information about the detected objects (received from detectors)
            targetUpdateNamePrefix (str, optional):
            cameranames (list[str], optional):
            countOverlappingPoints (bool, optional):
            overlapUpAxis (list, optional):
            zthresholdmult (float, optional):
            addUnpickableRegionAcrossShortEdgeDist (bool, optional):
            sizeRoundUp (bool, optional): If False, then round down. (Default: True)
            sizePrecisionXYZ (list, optional): mm (x,y,z) for rounding up incoming boxes from the detector. This allows previous grasping models to be cached and re-used since the sizes will be multiples of the current precision.
            points (list[float], optional): The point cloud passed in along with the detection results. Used in selective cases to count point overlap of random box.
            pointsize (float, optional): Size of points in the point cloud.
            pointcloudid (str, optional):
            locationName (str, optional): Name of the location to update.
            containerName (str, optional): Name of the container to update. Requires locationName to be set. If containerName is empty, will use the container in locationName.
            locationContainerId (str, optional):
            isFromStateSlaveNotify (bool, optional):
            imageStartTimeStampMS (int, optional):
            imageEndTimeStampMS (int, optional):
            belowBoxOverlap (float, optional): mm, Threshold on how much to ignore the relative heights of two neighboring targets to determine if the candidate is *below* the current pickup target. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes detection error can cause two targets on the same height to be overlapped a little, but that doesn't mean that one target is on top of the other. (Default: 0)
            ignoreOverlapPointsFromWall (float, optional): mm, distance from the container inner walls within which pointcloud points do not count towards overlapping points (Default: 0)
            ignoreOverlapPointsFromNearbyTargets (float, optional): mm, amount of target extents reduction when counting the number of overlapping pointcloud points. This is so that pointcloud near the edges of the target (can come from noises from nearby targets, for example) can be ignored. (Default: 0)
            castPointCloudShadowFromCamera (bool, optional): If True, bottom parts of pointcloud obstacle are generated by casting shadow from camera. otherwise, vertical down (-z).
            pointsProjectedDirection (list, optional): The negative direction in which the points were projected when creating the obstacles. If specified, then take into account when computing the overlap. When container up is +Z, then pointsProjectedDirection will be (0,0,1).
            randomBoxOrigin (list, optional): Specifies where to place the origin of the incoming box detections. By default, this is [0,0,1], which means the origin will be at the center of the +Z (top) face.
            rollStepDegree (float, optional): Step of 6D grasp rotation around z axis in degrees, defaults to 45 degrees. (Default: 90)
            clampToContainer (bool, optional): If True, crop to container dimensions.
            medianFilterHalfSize (float, optional): If clampcontainer is True, this is used for filtering.
            useEmptyRegionForCropping (bool, optional): If clampcontainer is True, this is used for filtering.
            cropContainerMarginsXYZXYZ (list, optional): Margin defining an axis aligned bounding box to limit point cloud data for the container. Values are measured from the interior of container edges. Positive value means cropping, negative value means additional margin. 
            ioSignalsInfo (dict, optional): Struct for dictating if any IO signals should be written on receiving detection results
            addPointOffsetInfo (dict, optional): Special offsets from pointcloud
        """
        taskparameters = {
            'command': 'UpdateObjects',
            'belowBoxOverlap': belowBoxOverlap,
            'ignoreOverlapPointsFromWall': ignoreOverlapPointsFromWall,
            'ignoreOverlapPointsFromNearbyTargets': ignoreOverlapPointsFromNearbyTargets,
            'rollStepDegree': rollStepDegree,
            'envstate': envstate,
            'unit': unit,
        }
        if object_uri is not None:
            taskparameters['object_uri'] = object_uri
        if callerid is not None:
            taskparameters['callerid'] = callerid
        if detectionResultState is not None:
            taskparameters['detectionResultState'] = detectionResultState
        if targetUpdateNamePrefix is not None:
            taskparameters['targetUpdateNamePrefix'] = targetUpdateNamePrefix
        if cameranames is not None:
            taskparameters['cameranames'] = cameranames
        if countOverlappingPoints is not None:
            taskparameters['countOverlappingPoints'] = countOverlappingPoints
        if overlapUpAxis is not None:
            taskparameters['overlapUpAxis'] = overlapUpAxis
        if zthresholdmult is not None:
            taskparameters['zthresholdmult'] = zthresholdmult
        if addUnpickableRegionAcrossShortEdgeDist is not None:
            taskparameters['addUnpickableRegionAcrossShortEdgeDist'] = addUnpickableRegionAcrossShortEdgeDist
        if sizeRoundUp is not None:
            taskparameters['sizeRoundUp'] = sizeRoundUp
        if sizePrecisionXYZ is not None:
            taskparameters['sizePrecisionXYZ'] = sizePrecisionXYZ
        if points is not None:
            taskparameters['points'] = points
        if pointsize is not None:
            taskparameters['pointsize'] = pointsize
        if pointcloudid is not None:
            taskparameters['pointcloudid'] = pointcloudid
        if locationName is not None:
            taskparameters['locationName'] = locationName
        if containerName is not None:
            taskparameters['containerName'] = containerName
        if locationContainerId is not None:
            taskparameters['locationContainerId'] = locationContainerId
        if isFromStateSlaveNotify is not None:
            taskparameters['isFromStateSlaveNotify'] = isFromStateSlaveNotify
        if imageStartTimeStampMS is not None:
            taskparameters['imageStartTimeStampMS'] = imageStartTimeStampMS
        if imageEndTimeStampMS is not None:
            taskparameters['imageEndTimeStampMS'] = imageEndTimeStampMS
        if castPointCloudShadowFromCamera is not None:
            taskparameters['castPointCloudShadowFromCamera'] = castPointCloudShadowFromCamera
        if pointsProjectedDirection is not None:
            taskparameters['pointsProjectedDirection'] = pointsProjectedDirection
        if randomBoxOrigin is not None:
            taskparameters['randomBoxOrigin'] = randomBoxOrigin
        if clampToContainer is not None:
            taskparameters['clampToContainer'] = clampToContainer
        if medianFilterHalfSize is not None:
            taskparameters['medianFilterHalfSize'] = medianFilterHalfSize
        if useEmptyRegionForCropping is not None:
            taskparameters['useEmptyRegionForCropping'] = useEmptyRegionForCropping
        if cropContainerMarginsXYZXYZ is not None:
            taskparameters['cropContainerMarginsXYZXYZ'] = cropContainerMarginsXYZXYZ
        if ioSignalsInfo is not None:
            taskparameters['ioSignalsInfo'] = ioSignalsInfo
        if addPointOffsetInfo is not None:
            taskparameters['addPointOffsetInfo'] = addPointOffsetInfo
        if state is not None:
            taskparameters['state'] = json.dumps(state)
        if targetname is not None:
            taskparameters['objectname'] = targetname
            taskparameters['object_uri'] = u'mujin:/%s.mujin.dae' % (targetname)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def Grab(self, targetname, toolname=None, timeout=10, **ignoredArgs):
        """Grabs an object with tool

        Args:
            targetname (str): Name of the target object
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'Grab',
            'targetname': targetname,
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def Release(self, targetname, timeout=10, **ignoredArgs):
        """Releases a grabbed object.

        Args:
            targetname (str): Name of the target object
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'Release',
            'targetname': targetname,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetGrabbed(self, timeout=10, **ignoredArgs):
        """Gets the names of the objects currently grabbed

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            Names of the grabbed object in a JSON dictionary, e.g. {'names': ['target_0']}

        """
        taskparameters = {
            'command': 'GetGrabbed',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetTransform(self, targetname, connectedBodyName=None, linkName=None, geometryName=None, geometryPk=None, unit='mm', timeout=10, **ignoredArgs):
        """Gets the transform of an object

        Args:
            targetname (str): OpenRave Kinbody name
            connectedBodyName (str, optional): OpenRave connected body name
            linkName (str, optional): OpenRave link name
            geometryName (str, optional): OpenRave geometry id name
            geometryPk (str, optional): OpenRave geometry primary key (pk)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            Transform of the object in a JSON dictionary, e.g. {'translation': [100,200,300], 'rotationmat': [[1,0,0],[0,1,0],[0,0,1]], 'quaternion': [1,0,0,0]}

        """
        taskparameters = {
            'command': 'GetTransform',
            'targetname': targetname,
            'unit': unit,
        }
        if connectedBodyName is not None:
            taskparameters['connectedBodyName'] = connectedBodyName
        if linkName is not None:
            taskparameters['linkName'] = linkName
        if geometryName is not None:
            taskparameters['geometryName'] = geometryName
        if geometryPk is not None:
            taskparameters['geometryPk'] = geometryPk
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetTransform(self, targetname, translation, unit='mm', rotationmat=None, quaternion=None, timeout=10, **ignoredArgs):
        """Sets the transform of an object. Rotation can be specified by either quaternion or rotation matrix.

        Args:
            targetname (str): Name of the target object
            translation (list[float]): List of x,y,z values of the object in millimeters.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            rotationmat (list[float], optional): List specifying the rotation matrix in row major format, e.g. [1,0,0,0,1,0,0,0,1]
            quaternion (list[float], optional): List specifying the quaternion in w,x,y,z format, e.g. [1,0,0,0].
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'SetTransform',
            'targetname': targetname,
            'translation': translation,
            'unit': unit,
        }
        if rotationmat is not None:
            taskparameters['rotationmat'] = rotationmat
        if quaternion is not None:
            taskparameters['quaternion'] = quaternion
        if rotationmat is None and quaternion is None:
            taskparameters['quaternion'] = [1, 0, 0, 0]
            log.warn('No rotation is specified. Using identity quaternion.')
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetOBB(self, targetname, unit='mm', timeout=10, linkname=None, **ignoredArgs):
        """Get the oriented bounding box (OBB) of object.

        Args:
            targetname (str): Name of the object
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            linkname (str, optional): Name of link to use for OBB. If not specified, uses entire target.

        Returns:
            A dictionary describing the OBB of the object with keys: extents, boxLocalTranslation, originalBodyTranslation, quaternion, rotationmat, translation

        """
        taskparameters = {
            'command': 'GetOBB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInnerEmptyRegionOBB(self, targetname, linkname=None, unit='mm', timeout=10, **ignoredArgs):
        """Get the inner empty oriented bounding box (OBB) of a container.

        Args:
            targetname (str): Name of the object
            linkname (str, optional): Name of link to use for OBB. If not specified, uses entire target.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            A dict describing the OBB of the object with keys: extents, boxLocalTranslation, originalBodyTranslation, quaternion, rotationmat, translation

        """
        taskparameters = {
            'command': 'GetInnerEmptyRegionOBB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInstObjectAndSensorInfo(self, instobjectnames=None, sensornames=None, unit='mm', timeout=10, ignoreMissingObjects=None, **ignoredArgs):
        """Returns information about the inst objects and sensors that are a part of those inst objects.

        Args:
            instobjectnames (list[str], optional):
            sensornames (list[str], optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            ignoreMissingObjects (bool, optional): If False, will raise an error if the object is not found in the scene. Default: True.
        """
        taskparameters = {
            'command': 'GetInstObjectAndSensorInfo',
            'unit': unit,
        }
        if instobjectnames is not None:
            taskparameters['instobjectnames'] = instobjectnames
        if sensornames is not None:
            taskparameters['sensornames'] = sensornames
        if ignoreMissingObjects is not None:
            taskparameters['ignoreMissingObjects'] = ignoreMissingObjects
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetInstObjectInfoFromURI(self, instobjecturi=None, unit='mm', timeout=10, instobjectpose=None, **ignoredArgs):
        """Opens a URI and returns info about the internal/external and geometry info from it.

        Args:
            instobjecturi (str, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            instobjectpose (list[float], optional): Pose to be assigned to the retrieved object. 7-element list
        """
        taskparameters = {
            'command': 'GetInstObjectInfoFromURI',
            'unit': unit,
        }
        if instobjecturi is not None:
            taskparameters['objecturi'] = instobjecturi
        if instobjectpose is not None:
            taskparameters['instobjectpose'] = instobjectpose
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetAABB(self, targetname, unit='mm', timeout=10, linkname=None, **ignoredArgs):
        """Gets the axis-aligned bounding box (AABB) of an object.

        Args:
            targetname (str): Name of the object
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            linkname (str, optional): Name of link to use for the AABB. If not specified, uses entire target.

        Returns:
            AABB of the object, e.g. {'pos': [1000,400,100], 'extents': [100,200,50]}

        """
        taskparameters = {
            'command': 'GetAABB',
            'targetname': targetname,
            'unit': unit,
        }
        if linkname is not None:
            taskparameters['linkname'] = linkname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetLocationTracking(self, timeout=10, fireandforget=False, cycleIndex=None, locationReplaceInfos=None, removeLocationNames=None, minRobotBridgeTimeStampUS=None, dynamicObstacleBaseName=None, targetUpdateBaseName=None, ioSignalsInfo=None, unit='mm', **ignoredArgs):
        """Resets the tracking of specific containers

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            cycleIndex: The cycle index to track the locations for
            locationReplaceInfos: A dict that should have the keys: name, containerDynamicProperties, rejectContainerIds, uri, pose, cycleIndex
            removeLocationNames (list[str], optional):
            minRobotBridgeTimeStampUS (int, optional): The minimum expected time stamp.
            dynamicObstacleBaseName (str, optional):
            targetUpdateBaseName (str, optional):
            ioSignalsInfo (dict, optional): Struct for dictating if any IO signals should be written on receiving detection results
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'SetLocationTracking',
            'unit': unit,
        }
        if cycleIndex is not None:
            taskparameters['cycleIndex'] = cycleIndex
        if locationReplaceInfos is not None:
            taskparameters['locationReplaceInfos'] = locationReplaceInfos
        if removeLocationNames is not None:
            taskparameters['removeLocationNames'] = removeLocationNames
        if minRobotBridgeTimeStampUS is not None:
            taskparameters['minRobotBridgeTimeStampUS'] = minRobotBridgeTimeStampUS
        if dynamicObstacleBaseName is not None:
            taskparameters['dynamicObstacleBaseName'] = dynamicObstacleBaseName
        if targetUpdateBaseName is not None:
            taskparameters['targetUpdateBaseName'] = targetUpdateBaseName
        if ioSignalsInfo is not None:
            taskparameters['ioSignalsInfo'] = ioSignalsInfo
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetLocationTracking(self, timeout=10, fireandforget=False, resetAllLocations=None, resetLocationName=None, resetLocationNames=None, checkIdAndResetLocationName=None, **ignoredArgs):
        """Resets tracking updates for locations

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            resetAllLocations (bool, optional): If True, then will reset all the locations
            resetLocationName (str, optional): Resets only the location with matching name
            resetLocationNames (list[str], optional): Resets only locations with matching name
            checkIdAndResetLocationName: (locationName, containerId) - only reset the location if the container id matches

        Returns:
            clearedLocationNames

        """
        taskparameters = {
            'command': 'ResetLocationTracking',
        }
        if resetAllLocations is not None:
            taskparameters['resetAllLocations'] = resetAllLocations
        if resetLocationName is not None:
            taskparameters['resetLocationName'] = resetLocationName
        if resetLocationNames is not None:
            taskparameters['resetLocationNames'] = resetLocationNames
        if checkIdAndResetLocationName is not None:
            taskparameters['checkIdAndResetLocationName'] = checkIdAndResetLocationName
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget).get('clearedLocationNames', None)

    def GetLocationTrackingInfos(self, fireandforget=False, timeout=10, **ignoredArgs):
        """Gets the active tracked locations

        Args:
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)

        Returns:
            activeLocationTrackingInfos

        """
        taskparameters = {
            'command': 'GetLocationTrackingInfos',
        }
        return self.ExecuteCommand(taskparameters, fireandforget=fireandforget, timeout=timeout).get('activeLocationTrackingInfos', None)

    def UpdateLocationContainerIdType(self, locationName, containerName, containerId, containerType, trackingCycleIndex=None, timeout=10, fireandforget=False, unit='mm', **ignoredArgs):
        """Resets the tracking of specific containers

        Args:
            locationName (str): Name of the location the container is in
            containerName (str): Name of the container
            containerId (str): ID of the container
            containerType (str): Type of the container
            trackingCycleIndex: If specified, then the cycle with same cycleIndex will update location tracking in the same call.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            unit (str, optional): The unit of the given values. (Default: 'mm')
        """
        taskparameters = {
            'command': 'UpdateLocationContainerIdType',
            'locationName': locationName,
            'containerName': containerName,
            'containerId': containerId,
            'containerType': containerType,
            'unit': unit,
        }
        if trackingCycleIndex is not None:
            taskparameters['trackingCycleIndex'] = trackingCycleIndex
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetLocationTrackingContainerId(self, locationName, checkContainerId, timeout=10, fireandforget=False, **ignoredArgs):
        """Resets the containerId of self._activeLocationTrackingInfos if it matches checkContainerId.

        Args:
            locationName (str): The name of the location that may be reset.
            checkContainerId: If checkContainerId is specified and not empty and it matches the current containerId of the tracking location, then reset the current tracking location
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetLocationTrackingContainerId',
            'locationName': locationName,
            'checkContainerId': checkContainerId,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def RemoveObjectsWithPrefix(self, prefix=None, removeNamePrefixes=None, timeout=10, fireandforget=False, removeLocationNames=None, doRemoveOnlyDynamic=None, **ignoredArgs):
        """Removes objects with prefix.

        Args:
            prefix (str, optional): (DEPRECATED)
            removeNamePrefixes (list[str], optional): Names of prefixes to match with when removing items
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            removeLocationNames (list[str], optional):
            doRemoveOnlyDynamic (bool, optional): If True, removes objects that were added through dynamic means such as UpdateObjects/UpdateEnvironmentState. Default: False

        Returns:
            With key 'removedBodyNames' for the removed object names

        """
        taskparameters = {
            'command': 'RemoveObjectsWithPrefix',
        }
        if prefix is not None:
            taskparameters['prefix'] = prefix
        if removeNamePrefixes is not None:
            taskparameters['removeNamePrefixes'] = removeNamePrefixes
        if removeLocationNames is not None:
            taskparameters['removeLocationNames'] = removeLocationNames
        if doRemoveOnlyDynamic is not None:
            taskparameters['doRemoveOnlyDynamic'] = doRemoveOnlyDynamic
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetTrajectoryLog(self, timeout=10, startindex=None, num=None, includejointvalues=False, saverawtrajectories=None, **ignoredArgs):
        """Gets the recent trajectories executed on the binpicking server. The internal server keeps trajectories around for 10 minutes before clearing them.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            startindex (int, optional): Start of the trajectory to get. If negative, will start counting from the end. For example, -1 is the last element, -2 is the second to last. Default: 0
            num (int, optional): Number of trajectories from startindex to return. If 0, will return all the trajectories starting from startindex. Default: 0
            includejointvalues (bool, optional): If True, will include timedjointvalues. If False, will just give back the trajectories.
            saverawtrajectories (bool, optional): If True, will save the raw trajectories.

        Returns:
            A dict with structure: 
                total: 10
                trajectories: [
                {
                "timestarted": 12345215
                "name": "movingtodest",
                "numpoints": 100,
                "duration": 0.8,
                "timedjointvalues": [0, 0, 0, .....]
                },
                { ... }
                ]
                
                Where timedjointvalues is a list of joint values and the trajectory time. For a 3DOF robot sampled at 0.008s, this is
                [J1, J2, J3, 0, J1, J2, J3, 0.008, J1, J2, J3, 0.016, ...]

        """
        taskparameters = {
            'command': 'GetTrajectoryLog',
            'includejointvalues': includejointvalues,
        }
        if saverawtrajectories is not None:
            taskparameters['saverawtrajectories'] = saverawtrajectories
        if startindex is not None:
            taskparameters['startindex'] = startindex
        if num is not None:
            taskparameters['num'] = num
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ChuckGripper(self, robotname=None, grippername=None, timeout=10, toolname=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Chucks the manipulator

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'ChuckGripper',
        }
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def UnchuckGripper(self, robotname=None, grippername=None, timeout=10, targetname=None, toolname=None, pulloutdist=None, deletetarget=None, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Unchucks the manipulator and releases the target

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            targetname (str, optional): Name of the target object.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            pulloutdist (float, optional): Distance to move away along the tool direction after releasing.
            deletetarget (int, optional): If 1, removes the target object from the environment after releasing. (Default: 1)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'UnchuckGripper',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if targetname is not None:
            taskparameters['targetname'] = targetname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if pulloutdist is not None:
            taskparameters['pulloutdist'] = pulloutdist
        if deletetarget is not None:
            taskparameters['deletetarget'] = deletetarget
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def CalibrateGripper(self, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Goes through the gripper calibration procedure

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'CalibrateGripper',
        }
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def StopGripper(self, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """

        Args:
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'StopGripper',
        }
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def MoveGripper(self, grippervalues, robotname=None, grippername=None, timeout=10, fireandforget=False, toolname=None, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Moves the chuck of the manipulator to a given value.

        Args:
            grippervalues (list[float]): Target value(s) of the chuck.
            robotname (str, optional): Name of the robot
            grippername (str, optional): Name of the gripper.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'MoveGripper',
            'unit': unit,
            'grippervalues': grippervalues,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if grippername is not None:
            taskparameters['grippername'] = grippername
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ExecuteRobotProgram(self, robotProgramName, robotname=None, timeout=10, fireandforget=False, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Execute a robot specific program by name

        Args:
            robotProgramName (str):
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'ExecuteRobotProgram',
            'unit': unit,
            'robotProgramName': robotProgramName,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SaveScene(self, timeout=10, filename=None, preserveexternalrefs=None, externalref=None, saveclone=None, saveReferenceUriAsHint=None, **ignoredArgs):
        """Saves the current scene to file

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            filename (str, optional): e.g. /tmp/testscene.mujin.dae, if not specified, it will be saved with an auto-generated filename
            preserveexternalrefs (bool, optional): If True, any bodies that are currently being externally referenced from the environment will be saved as external references.
            externalref (str, optional): If '*', then each of the objects will be saved as externally referencing their original filename. Otherwise will force saving specific bodies as external references.
            saveclone: (DEPRECATED) If 1, will save the scenes for all the cloned environments
            saveReferenceUriAsHint (bool, optional): If True, use save the reference uris as referenceUriHint so that webstack does not get confused and deletes content

        Returns:
            The filename the scene is saved to, in a json dictionary, e.g. {'filename': '2013-11-01-17-10-00-UTC.dae'}

        """
        taskparameters = {
            'command': 'SaveScene',
        }
        if filename is not None:
            taskparameters['filename'] = filename
        if preserveexternalrefs is not None:
            taskparameters['preserveexternalrefs'] = preserveexternalrefs
        if externalref is not None:
            taskparameters['externalref'] = externalref
        if saveclone is not None:
            taskparameters['saveclone'] = saveclone
        if saveReferenceUriAsHint is not None:
            taskparameters['saveReferenceUriAsHint'] = saveReferenceUriAsHint
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SaveGripper(self, timeout=10, robotname=None, filename=None, manipname=None, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """Separate gripper from a robot in a scene and save it.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotname (str, optional): Name of the robot waiting to extract the hand from.
            filename (str, optional): File name to save on the file system. e.g. /tmp/robotgripper/mujin.dae
            manipname (str, optional): Name of the manipulator.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'SaveGripper',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if filename is not None:
            taskparameters['filename'] = filename
        if manipname is not None:
            taskparameters['manipname'] = manipname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJointsToJointConfigurationStates(
        self,
        jointConfigurationStates,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startJointConfigurationStates=None,
        envclearance=None,
        timeout=10,
        jointStates=None,
        jointindices=None,
        unit='mm',
        robotBridgeConnectionInfo=None,
        locationCollisionInfos=None,
        ionames=None,
        constraintToolDirection=None,
        departOffsetDir=None,
        departOffsetAwayFromGravity=None,
        trajname=None,
        disablebodies=None,
        ignoreGrabbingTarget=None,
        jointthresh=None,
        jitter=None,
        executionFilterFactor=None,
        filtertraj=None,
        currentlimitratios=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        calibrategripper=None,
        departAccel=None,
        maxManipAccel=None,
        maxJitterLinkDist=None,
        **ignoredArgs
    ):
        """Moves the robot to desired joint angles specified in jointStates

        Args:
            jointConfigurationStates:
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startJointConfigurationStates:
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointStates (list, optional): List[{'jointName':str, 'jointValue':float}]
            jointindices (list[int], optional): List of corresponding joint indices, default is range(len(jointvalues))
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            ionames (list, optional): A list of IO names to read/write
            constraintToolDirection (list[float], optional):
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departOffsetAwayFromGravity (float, optional): Overridden by departOffsetDir
            trajname (str, optional):
            disablebodies (bool, optional):
            ignoreGrabbingTarget (bool, optional):
            jointthresh (float, optional):
            jitter (float, optional):
            executionFilterFactor (float, optional):
            filtertraj (bool, optional):
            currentlimitratios (list[float], optional): The joints' current limt ratios.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            calibrategripper (bool, optional):
            departAccel (float, optional):
            maxManipAccel (float, optional):
            maxJitterLinkDist (float, optional): mm.
        """
        taskparameters = {
            'command': 'MoveJointsToJointConfigurationStates',
            'unit': unit,
            'execute': execute,
            'goalJointConfigurationStates': jointConfigurationStates,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if trajname is not None:
            taskparameters['trajname'] = trajname
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if startJointConfigurationStates is not None:
            taskparameters['startJointConfigurationStates'] = startJointConfigurationStates
        if jointStates is not None:
            taskparameters['jointStates'] = jointStates
        if jointindices is not None:
            taskparameters['jointindices'] = jointindices
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJoints(
        self,
        jointvalues,
        jointindices=None,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startvalues=None,
        envclearance=None,
        timeout=10,
        robotProgramName=None,
        goaljoints='None',
        unit='mm',
        robotBridgeConnectionInfo=None,
        locationCollisionInfos=None,
        ionames=None,
        constraintToolDirection=None,
        departOffsetDir=None,
        departOffsetAwayFromGravity=None,
        trajname=None,
        disablebodies=None,
        ignoreGrabbingTarget=None,
        jointthresh=None,
        jitter=None,
        executionFilterFactor=None,
        filtertraj=None,
        currentlimitratios=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        calibrategripper=None,
        departAccel=None,
        maxManipAccel=None,
        maxJitterLinkDist=None,
        forceTorqueBasedEstimatorParameters=None,
        **ignoredArgs
    ):
        """Moves the robot to desired joint angles specified in jointvalues

        Args:
            jointvalues (list[float]): (DEPRECATED. Use goaljoints) List of joint values to move to.
            jointindices (list[int], optional): List of corresponding joint indices, default is range(len(jointvalues))
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startvalues (list[float], optional): The robot joint values to start the motion from.
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            robotProgramName (str, optional):
            goaljoints (list[float], optional): List of joint values to move to. (Default: 'None')
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            ionames (list, optional): A list of IO names to read/write
            constraintToolDirection (list[float], optional):
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departOffsetAwayFromGravity (float, optional): Overridden by departOffsetDir
            trajname (str, optional):
            disablebodies (bool, optional):
            ignoreGrabbingTarget (bool, optional):
            jointthresh (float, optional):
            jitter (float, optional):
            executionFilterFactor (float, optional):
            filtertraj (bool, optional):
            currentlimitratios (list[float], optional): The joints' current limt ratios.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            calibrategripper (bool, optional):
            departAccel (float, optional):
            maxManipAccel (float, optional):
            maxJitterLinkDist (float, optional): mm.
            forceTorqueBasedEstimatorParameters (dict, optional): A set of parameters for force-torque based estimation.
        """
        taskparameters = {
            'command': 'MoveJoints',
            'unit': unit,
            'execute': execute,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if trajname is not None:
            taskparameters['trajname'] = trajname
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if forceTorqueBasedEstimatorParameters is not None:
            taskparameters['forceTorqueBasedEstimatorParameters'] = forceTorqueBasedEstimatorParameters
        taskparameters['goaljoints'] = jointvalues
        if goaljoints is not None:
            taskparameters['goaljoints'] = goaljoints
        if jointindices is None:
            jointindices = range(len(jointvalues))
            log.warn(u'No jointindices specified. Moving joints with default jointindices: %s', jointindices)
        taskparameters['jointindices'] = list(jointindices)
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if startvalues is not None:
            taskparameters['startvalues'] = list(startvalues)
        if robotProgramName is not None:
            taskparameters['robotProgramName'] = list(robotProgramName)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveJointsToPositionConfiguration(
        self,
        positionConfigurationName=None,
        positionConfigurationCandidateNames=None,
        robotname=None,
        robotspeed=None,
        robotaccelmult=None,
        execute=1,
        startvalues=None,
        envclearance=None,
        timeout=10,
        unit='mm',
        robotBridgeConnectionInfo=None,
        locationCollisionInfos=None,
        ionames=None,
        constraintToolDirection=None,
        departOffsetDir=None,
        departOffsetAwayFromGravity=None,
        trajname=None,
        disablebodies=None,
        ignoreGrabbingTarget=None,
        jointthresh=None,
        jitter=None,
        executionFilterFactor=None,
        filtertraj=None,
        currentlimitratios=None,
        goalJointThreshold=None,
        goalWorkspaceThreshold=None,
        calibrategripper=None,
        departAccel=None,
        maxManipAccel=None,
        maxJitterLinkDist=None,
        startJointConfigurationStates=None,
        robotProgramName=None,
        forceTorqueBasedEstimatorParameters=None,
        **ignoredArgs
    ):
        """Moves the robot to desired position configuration specified in positionConfigurationName

        Args:
            positionConfigurationName (str, optional): If specified, the name of position configuration to move to. If it does not exist, will raise an error.
            positionConfigurationCandidateNames (list[str], optional): If specified, goes to the first position that is defined for the robot. If no positions exist, returns without moving the robot.
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startvalues (list[float], optional): The robot joint values to start the motion from.
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            ionames (list, optional): A list of IO names to read/write
            constraintToolDirection (list[float], optional):
            departOffsetDir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departOffsetAwayFromGravity (float, optional): Overridden by departOffsetDir
            trajname (str, optional):
            disablebodies (bool, optional):
            ignoreGrabbingTarget (bool, optional):
            jointthresh (float, optional):
            jitter (float, optional):
            executionFilterFactor (float, optional):
            filtertraj (bool, optional):
            currentlimitratios (list[float], optional): The joints' current limt ratios.
            goalJointThreshold (list[float], optional): Threshold of the sum of abs joint differences between what the robot is able to achieve and where the goal is, in degrees. If not within this threshold, robot tries to reach goal, during some time.
            goalWorkspaceThreshold (float, optional): Threshold in mm. If the robot manipulator is within this threshold to the goal position, then trajectory is assumed to be successful.
            calibrategripper (bool, optional):
            departAccel (float, optional):
            maxManipAccel (float, optional):
            maxJitterLinkDist (float, optional): mm.
            startJointConfigurationStates (list[dict], optional): List of dicts for each joint.
            robotProgramName (str, optional):
            forceTorqueBasedEstimatorParameters (dict, optional): A set of parameters for force-torque based estimation.

        Returns:
            Dictionary with keys goalPositionName and values goalConfiguration

        """
        taskparameters = {
            'command': 'MoveJointsToPositionConfiguration',
            'unit': unit,
            'execute': execute,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if constraintToolDirection is not None:
            taskparameters['constraintToolDirection'] = constraintToolDirection
        if departOffsetDir is not None:
            taskparameters['departOffsetDir'] = departOffsetDir
        if departOffsetAwayFromGravity is not None:
            taskparameters['departOffsetAwayFromGravity'] = departOffsetAwayFromGravity
        if trajname is not None:
            taskparameters['trajname'] = trajname
        if disablebodies is not None:
            taskparameters['disablebodies'] = disablebodies
        if ignoreGrabbingTarget is not None:
            taskparameters['ignoreGrabbingTarget'] = ignoreGrabbingTarget
        if jointthresh is not None:
            taskparameters['jointthresh'] = jointthresh
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if jitter is not None:
            taskparameters['jitter'] = jitter
        if executionFilterFactor is not None:
            taskparameters['executionFilterFactor'] = executionFilterFactor
        if filtertraj is not None:
            taskparameters['filtertraj'] = filtertraj
        if currentlimitratios is not None:
            taskparameters['currentlimitratios'] = currentlimitratios
        if goalJointThreshold is not None:
            taskparameters['goalJointThreshold'] = goalJointThreshold
        if goalWorkspaceThreshold is not None:
            taskparameters['goalWorkspaceThreshold'] = goalWorkspaceThreshold
        if calibrategripper is not None:
            taskparameters['calibrategripper'] = calibrategripper
        if departAccel is not None:
            taskparameters['departAccel'] = departAccel
        if maxManipAccel is not None:
            taskparameters['maxManipAccel'] = maxManipAccel
        if maxJitterLinkDist is not None:
            taskparameters['maxJitterLinkDist'] = maxJitterLinkDist
        if startJointConfigurationStates is not None:
            taskparameters['startJointConfigurationStates'] = startJointConfigurationStates
        if robotProgramName is not None:
            taskparameters['robotProgramName'] = robotProgramName
        if forceTorqueBasedEstimatorParameters is not None:
            taskparameters['forceTorqueBasedEstimatorParameters'] = forceTorqueBasedEstimatorParameters
        if positionConfigurationName is not None:
            taskparameters['positionConfigurationName'] = positionConfigurationName
        if positionConfigurationCandidateNames is not None:
            taskparameters['positionConfigurationCandidateNames'] = positionConfigurationCandidateNames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if startvalues is not None:
            taskparameters['startvalues'] = list(startvalues)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetRobotBridgeIOVariables(self, ioname=None, ionames=None, robotname=None, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """Returns the data of the IO in ASCII hex as a string

        Args:
            ioname (str, optional): One IO name to read
            ionames (list, optional): A list of the IO names to read
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'GetRobotBridgeIOVariables',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if ioname is not None and len(ioname) > 0:
            taskparameters['ioname'] = ioname
        if ionames is not None and len(ionames) > 0:
            taskparameters['ionames'] = ionames
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgeIOVariables(self, iovalues, robotname=None, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, forceasync=None, **ignoredArgs):
        """Sets a set of IO variables in the robot bridge.

        This should not lock self.env since it can happen during the runtime of a task and lock out other functions waiting in the queue.

        Args:
            iovalues:
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            forceasync (bool, optional):
        """
        taskparameters = {
            'command': 'SetRobotBridgeIOVariables',
            'unit': unit,
            'iovalues': list(iovalues),
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if forceasync is not None:
            taskparameters['forceasync'] = forceasync
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeIkParamPosition(self, name, robotname=None, timeout=10, unit='mm', jointvalues=None, **ignoredArgs):
        """Given the name of a Kinbody, computes the manipulator (TCP) position in the kinbody frame to generate values for an IKParameterization.

        Args:
            name (str): Name of the Kinbody (the robot).
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            jointvalues (list[float], optional): If given, the robot's joints are set to these values before calculating the manipulator (TCP) position. If not set, uses the current values.

        Returns:
            A dictionary with the structure:

            translation (list[float]): List of x,y,z values of the object in millimeters.
            quaternion (list[float]): List specifying the quaternion in w,x,y,z format, e.g. [1,0,0,0].
            direction (list): The global direction of the manipulator (assuming that the direction of the manipulator is the positive Z-axis).
            angleXZ (float)
            angleYX (float)
            angleZY (float)
            angleX (float)
            angleY (float)
            angleZ (float)
        """
        taskparameters = {
            'command': 'ComputeIkParamPosition',
            'unit': unit,
            'name': name,
        }
        if jointvalues is not None:
            taskparameters['jointvalues'] = jointvalues
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeIKFromParameters(self, toolname=None, timeout=10, targetname=None, graspsetname=None, ikparamnames=None, limit=None, useSolutionIndices=None, disabletarget=None, unit='mm', randomBoxInfo=None, freeincvalue=None, freeinc=None, applyapproachoffset=None, inPlaneAngleDeviation=None, outOfPlaneAngleDeviation=None, searchfreeparams=None, returnClosestToCurrent=None, filteroptionslist=None, filteroptions=None, **ignoredArgs):
        """

        Args:
            toolname (str, optional): Tool name
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            targetname (str, optional): Name of the target object
            graspsetname (str, optional): Name of the grasp set to use
            ikparamnames (list[str], optional): If graspset does not exist, use the ikparamnames to initialize the grasp.
            limit (float, optional): Number of solutions to return
            useSolutionIndices (bool, optional):
            disabletarget (bool, optional):
            unit (str, optional): The unit of the given values. (Default: 'mm')
            randomBoxInfo (dict, optional): Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True). Keys: usefaces, dictFacePriorities, boxDirAngle, toolTranslationOffsets
            freeincvalue (float, optional): The discretization of the free joints of the robot when computing ik.
            freeinc (float, optional): (DEPRECATED) The discretization of the free joints of the robot when computing ik.
            applyapproachoffset (bool, optional):
            inPlaneAngleDeviation (float, optional):
            outOfPlaneAngleDeviation (float, optional):
            searchfreeparams (bool, optional):
            returnClosestToCurrent (bool, optional):
            filteroptionslist (list[str], optional): A list of filter option strings. Can be: CheckEnvCollisions, IgnoreCustomFilters, IgnoreEndEffectorCollisions, IgnoreEndEffectorEnvCollisions, IgnoreEndEffectorSelfCollisions, IgnoreJointLimits, IgnoreSelfCollisions. Overrides filteroptions.
            filteroptions (int, optional): OpenRAVE IkFilterOptions bitmask. By default this is 1, which means all collisions are checked

        Returns:
            A dictionary with field 'solutions': array of IK solutions (each of which is an array of DOF values), sorted by minimum travel distance and truncated to match the limit
            If no solutions found, the field 'errors' will contain reasons for the failure.

        """
        taskparameters = {
            'command': 'ComputeIKFromParameters',
            'unit': unit,
        }
        if targetname is not None:
            taskparameters['targetname'] = targetname
        if graspsetname is not None:
            taskparameters['graspsetname'] = graspsetname
        if ikparamnames is not None:
            taskparameters['ikparamnames'] = ikparamnames
        if limit is not None:
            taskparameters['limit'] = limit
        if useSolutionIndices is not None:
            taskparameters['useSolutionIndices'] = useSolutionIndices
        if disabletarget is not None:
            taskparameters['disabletarget'] = disabletarget
        if randomBoxInfo is not None:
            taskparameters['randomBoxInfo'] = randomBoxInfo
        if freeincvalue is not None:
            taskparameters['freeincvalue'] = freeincvalue
        if freeinc is not None:
            taskparameters['freeinc'] = freeinc
        if applyapproachoffset is not None:
            taskparameters['applyapproachoffset'] = applyapproachoffset
        if inPlaneAngleDeviation is not None:
            taskparameters['inPlaneAngleDeviation'] = inPlaneAngleDeviation
        if outOfPlaneAngleDeviation is not None:
            taskparameters['outOfPlaneAngleDeviation'] = outOfPlaneAngleDeviation
        if searchfreeparams is not None:
            taskparameters['searchfreeparams'] = searchfreeparams
        if returnClosestToCurrent is not None:
            taskparameters['returnClosestToCurrent'] = returnClosestToCurrent
        if filteroptionslist is not None:
            taskparameters['filteroptionslist'] = filteroptionslist
        if filteroptions is not None:
            taskparameters['filteroptions'] = filteroptions
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ShutdownRobotBridge(self, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'ShutdownRobotBridge',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetRobotBridgeState(self, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, ionames=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'GetRobotBridgeState',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ClearRobotBridgeError(self, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'ClearRobotBridgeError',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgePause(self, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'SetRobotBridgePause',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetRobotBridgeResume(self, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'SetRobotBridgeResume',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetJogModeVelocities(self, movejointsigns, robotname=None, toolname=None, robotspeed=None, robotaccelmult=None, canJogInCheckMode=None, timeout=1, fireandforget=False, jogtype=None, checkSelfCollisionWhileJogging=None, force=None, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotJogParameters=None, simulationtimestep=None, plotDirection=None, **ignoredArgs):
        """

        Args:
            movejointsigns (list[float]): Joint signs used for jogging. If less than the number of joints, will be padded with zeros.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] setting the percentage of robot acceleration to move at
            canJogInCheckMode (bool, optional): If True, then allow jogging even if in check mode. (Default: False)
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            jogtype (str, optional): One of 'joints', 'world', 'robot', 'tool'. (DEPRECATED: set this as a field in robotJogParameters instead)
            checkSelfCollisionWhileJogging (bool, optional):
            force (bool, optional): If true, forces the velocities to be set.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotJogParameters (dict, optional): A dictionary. Includes field 'jogtype' (One of 'joints', 'world', 'robot', 'tool').
            simulationtimestep (float, optional): Time step of the simulation.
            plotDirection (bool, optional): If True, plot the direction.
        """
        taskparameters = {
            'command': 'SetJogModeVelocities',
            'unit': unit,
            'movejointsigns': movejointsigns,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotJogParameters is not None:
            taskparameters['robotJogParameters'] = robotJogParameters
        if simulationtimestep is not None:
            taskparameters['simulationtimestep'] = simulationtimestep
        if plotDirection is not None:
            taskparameters['plotDirection'] = plotDirection
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if canJogInCheckMode is not None:
            taskparameters['canJogInCheckMode'] = canJogInCheckMode
        if jogtype is not None:
            taskparameters['jogtype'] = jogtype
        if checkSelfCollisionWhileJogging is not None:
            taskparameters['checkSelfCollisionWhileJogging'] = checkSelfCollisionWhileJogging
        if force is not None:
            taskparameters['force'] = force
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def EndJogMode(self, timeout=1, fireandforget=False, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
        """
        taskparameters = {
            'command': 'EndJogMode',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeServoOn(self, servoon, robotname=None, timeout=3, fireandforget=False, **ignoredArgs):
        """

        Args:
            servoon (bool): If True, turns servo on.
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeServoOn',
            'isservoon': servoon,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeLockMode(self, islockmode, robotname=None, timeout=3, fireandforget=False, **ignoredArgs):
        """

        Args:
            islockmode (bool): If True, turns on Lock Mode. During Lock Mode, all communication with the physical robot is turned off and the hardware will not move.
            robotname (str, optional): Name of the robot
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeLockMode',
            'islockmode': islockmode,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ResetSafetyFault(self, timeout=3, fireandforget=False, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetSafetyFault',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeControlMode(self, controlMode, timeout=3, fireandforget=False, **ignoredArgs):
        """

        Args:
            controlMode (str): The control mode to use, e.g. "Manual".
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 3)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeControlMode',
            'controlMode': controlMode,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetDynamicObjects(self, timeout=1, **ignoredArgs):
        """Get a list of dynamically added objects in the scene, from vision detection and physics simulation.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
        """
        taskparameters = {
            'command': 'GetDynamicObjects',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeRobotConfigsForGraspVisualization(self, targetname, graspname, robotname=None, toolname=None, unit='mm', timeout=10, approachoffset=None, departoffsetdir=None, departoffsetintool=None, shadowrobotname=None, shadowrobottoolname=None, **ignoredArgs):
        """Returns robot configs for grasp visualization

        Args:
            targetname (str): Target object's name.
            graspname (str): Name of the grasp for which to visualize grasps.
            robotname (str, optional): Name of the robot
            toolname (str, optional): Name of the manipulator.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            approachoffset (float, optional):
            departoffsetdir (list[float], optional): Direction in which to apply the offset when departing from the pick/place operation.
            departoffsetintool (list[float], optional):
            shadowrobotname (str, optional):
            shadowrobottoolname (str, optional):
        """
        taskparameters = {
            'command': 'ComputeRobotConfigsForGraspVisualization',
            'targetname': targetname,
            'graspname': graspname,
            'unit': unit,
        }
        if approachoffset is not None:
            taskparameters['approachoffset'] = approachoffset
        if departoffsetdir is not None:
            taskparameters['departoffsetdir'] = departoffsetdir
        if departoffsetintool is not None:
            taskparameters['departoffsetintool'] = departoffsetintool
        if shadowrobotname is not None:
            taskparameters['shadowrobotname'] = shadowrobotname
        if shadowrobottoolname is not None:
            taskparameters['shadowrobottoolname'] = shadowrobottoolname
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if toolname is not None:
            taskparameters['toolname'] = toolname
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ResetCacheTemplates(self, timeout=1, fireandforget=False, **ignoredArgs):
        """Resets any cached templates

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetCacheTemplates',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetRobotBridgeExternalIOPublishing(self, enable, timeout=2, fireandforget=False, **ignoredArgs):
        """Enables publishing collision data to the robotbridge

        Args:
            enable (bool): If True, collision data will be published to robotbridge.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 2)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'SetRobotBridgeExternalIOPublishing',
            'enable': bool(enable),
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def RestoreSceneInitialState(self, timeout=1, preserverobotdofvalues=1, **ignoredArgs):
        """Restores the scene to the state on the filesystem

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 1)
            preserverobotdofvalues (bool, optional): (Default: 1)
        """
        taskparameters = {
            'command': 'RestoreSceneInitialState',
            'preserverobotdofvalues': preserverobotdofvalues,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningStepTest(self, jointName, amplitude, timeout=10, **ignoredArgs):
        """Runs step response test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'RunMotorControlTuningStepTest',
            'jointName': jointName,
            'amplitude': amplitude,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningMaximulLengthSequence(self, jointName, amplitude, timeout=10, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Runs maximum length sequence test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'RunMotorControlTuningMaximulLengthSequence',
            'unit': unit,
            'jointName': jointName,
            'amplitude': amplitude,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningDecayingChirp(self, jointName, amplitude, freqMax, timeout=120, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """runs chirp test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            freqMax (float): The maximum frequency in Hz
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 120)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'RunMotorControlTuningDecayingChirp',
            'unit': unit,
            'jointName': jointName,
            'amplitude': amplitude,
            'freqMax': freqMax,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningGaussianImpulse(self, jointName, amplitude, timeout=20, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Runs Gaussian Impulse test on specified joint and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 20)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'RunMotorControlTuningGaussianImpulse',
            'unit': unit,
            'jointName': jointName,
            'amplitude': amplitude,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunMotorControlTuningBangBangResponse(self, jointName, amplitude, timeout=60, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """Runs bangbang trajectory in acceleration or jerk space and returns result

        Args:
            jointName (str): The name of the joint.
            amplitude (float): The amplitude.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 60)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'RunMotorControlTuningBangBangResponse',
            'unit': unit,
            'jointName': jointName,
            'amplitude': amplitude,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def RunDynamicsIdentificationTest(self, timeout, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """

        Args:
            timeout (float): Time in seconds after which the command is assumed to have failed. (Default: 4.0)
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'RunDynamicsIdentificationTest',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetTimeToRunDynamicsIdentificationTest(self, timeout=10, jointName=None, minJointAngle=None, maxJointAngle=None, unit='mm', robotBridgeConnectionInfo=None, locationCollisionInfos=None, robotspeed=None, robotaccelmult=None, ionames=None, **ignoredArgs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            jointName (str, optional): The name of the joint.
            minJointAngle (float, optional): The joint angle to start the dynamics identification test at.
            maxJointAngle (float, optional): The joint angle to finish the dynamics identification test at.
            unit (str, optional): The unit of the given values. (Default: 'mm')
            robotBridgeConnectionInfo (dict, optional): Information to set up a client to the robot bridge.
            locationCollisionInfos (dict, optional): List of external collision IOs to be computed and sent in realtime.
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            ionames (list, optional): A list of IO names to read/write
        """
        taskparameters = {
            'command': 'GetTimeToRunDynamicsIdentificationTest',
            'unit': unit,
        }
        if robotBridgeConnectionInfo is not None:
            taskparameters['robotBridgeConnectionInfo'] = robotBridgeConnectionInfo
        if locationCollisionInfos is not None:
            taskparameters['locationCollisionInfos'] = locationCollisionInfos
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if ionames is not None:
            taskparameters['ionames'] = ionames
        if jointName is not None:
            taskparameters['jointName'] = jointName
        if minJointAngle is not None:
            taskparameters['minJointAngle'] = minJointAngle
        if maxJointAngle is not None:
            taskparameters['maxJointAngle'] = maxJointAngle
        return self.ExecuteCommand(taskparameters, timeout=timeout)
    
    def CalculateTestRangeFromCollision(self, timeout=10, **kwargs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'CalculateTestRangeFromCollision',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameterSchema(self, timeout=10, **kwargs):
        """Gets motor control parameter schema

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'GetMotorControlParameterSchema',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameter(self, jointName, parameterName, timeout=10, **kwargs):
        """Gets motor control parameters as a name-value dict, e.g.: {'J1':{'KP':1}, 'J2':{'KV':2}}

        Args:
            jointName (str): The name of the joint.
            parameterName (str):
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'GetMotorControlParameter',
            'jointName': jointName,
            'parameterName': parameterName,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetMotorControlParameters(self, timeout=10, **kwargs):
        """Gets cached motor control parameters as name-value dict

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'GetMotorControlParameters',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetMotorControlParameter(self, jointName, parameterName, parameterValue, timeout=10, **kwargs):
        """Sets motor control parameter

        Args:
            jointName (str): The name of the joint.
            parameterName (str): The name of the parameter to set.
            parameterValue: The value to assign to the parameter.
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'SetMotorControlParameter',
            'jointName': jointName,
            'parameterName': parameterName,
            'parameterValue': parameterValue,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)
    
    def IsProfilingRunning(self, timeout=10):
        """Queries if profiling is running on planning

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'IsProfilingRunning',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StartProfiling(self, clocktype='cpu', timeout=10):
        """Start profiling planning

        Args:
            clocktype (str, optional): (Default: 'cpu')
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'StartProfiling',
            'clocktype': clocktype,
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StopProfiling(self, timeout=10):
        """Stop profiling planning

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
        """
        taskparameters = {
            'command': 'StopProfiling',
        }
        return self.ExecuteCommand(taskparameters, timeout=timeout)
    
    def ReplaceBodies(self, bodieslist, timeout=10, replaceInfos=None, **kwargs):
        """Replaces bodies in the environment with new uris

        Args:
            bodieslist:
            timeout (float, optional):  (Default: 10)
            replaceInfos (list[dict]): list of dicts with keys: name, uri, containerDynamicProperties
            testLocationName (str): If specified, will test if the container in this location matches testLocationContainerId, and only execute the replace if it matches and testLocationContainerId is not empty.
            testLocationContainerId (str): containerId used for testing logic with testLocationName
            removeNamePrefixes:
            removeLocationNames:
            doRemoveOnlyDynamic:
        """
        taskparameters = {
            'command': 'ReplaceBodies',
            'bodieslist': bodieslist, # for back compatibility for now
        }
        taskparameters['replaceInfos'] = bodieslist
        if replaceInfos is not None:
            taskparameters['replaceInfos'] = replaceInfos
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)
    
    def GetState(self, timeout=10, fireandforget=False, **kwargs):
        """

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10.0)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'GetState',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)
    
    def EnsureSyncWithRobotBridge(self, syncTimeStampUS, timeout=10, fireandforget=False, **kwargs):
        """Ensures that planning has synchronized with robotbridge data that is newer than syncTimeStampUS

        Args:
            syncTimeStampUS: us (microseconds, linux time) of the timestamp
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'EnsureSyncWithRobotBridge',
            'syncTimeStampUS': syncTimeStampUS,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)
    
    def ResetCachedRobotConfigurationState(self, timeout=10, fireandforget=False, **kwargs):
        """Resets cached robot configuration (position of the robot) in the planning slave received from slave notification. Need to perform every time robot moved not from the task slaves.

        Args:
            timeout (float, optional): Time in seconds after which the command is assumed to have failed. (Default: 10)
            fireandforget (bool, optional): If True, does not wait for the command to finish and returns immediately. The command remains queued on the server.
        """
        taskparameters = {
            'command': 'ResetCachedRobotConfigurationState',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)
