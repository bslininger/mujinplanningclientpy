# Copyright (C) 2012-2023 Mujin, Inc.

# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

from . import json
from . import realtimerobotplanningclient

import logging
log = logging.getLogger(__name__)

class BinpickingPlanningClient(realtimerobotplanningclient.RealtimeRobotPlanningClient):
    """Mujin planning client for the Binpicking task"""
    regionname = None  # The default region for Pick/Place calls
    _robotname = None  # Optional name of the robot selected
    _robotspeed = None  # Speed of the robot, e.g. 0.4
    _robotaccelmult = None  # Current robot accel mult
    _envclearance = None  # Environment clearance in millimeters, e.g. 20
    _robotBridgeConnectionInfo = None  # dict holding the connection info for the robot bridge.
    

    def __init__(
        self,
        regionname=None,
        robotname='',
        robotspeed=None,
        robotaccelmult=None,
        envclearance=10.0,
        robotBridgeConnectionInfo=None,
        scenepk='',
        controllerip='',
        controllerusername='',
        controllerpassword='',
        controllerurl='',
        tasktype='binpicking',
        slaverequestid=None,
        taskzmqport=7110,
        taskheartbeatport=7111,
        taskheartbeattimeout=7.0,
        ctx=None,
        author=None,
        **ignoredArgs  # Additional keyword args are not used, but allowed for easy initialization from a dictionary
    ):
        """Connects to the Mujin controller, initializes Binpicking task and sets up parameters

        Args:
            regionname (str, optional): Name of the bin, e.g. container1
            robotname (str, optional): Name of the robot, e.g. VP-5243I
            robotspeed (float, optional): Speed of the robot, e.g. 0.4
            robotaccelmult (float, optional): Optional multiplier for the robot acceleration.
            envclearance (str, optional): Environment clearance in millimeter, e.g. 20
            robotBridgeConnectionInfo (str, optional): dict holding the connection info for the robot bridge.
            scenepk (str, optional): Primary key (pk) of the scene, e.g. irex_demo.mujin.dae
            controllerip (str): IP or hostname of the mujin controller, e.g. 172.17.0.2 or controller123
            controllerusername (str): Username for the Mujin controller, e.g. testuser
            controllerpassword (str): Password for the Mujin controller
            controllerurl (str, optional): (Deprecated. Use controllerip instead) URL of the mujin controller, e.g. http://controller14.
            tasktype (str, optional): Type of the task, e.g. 'binpicking', 'handeyecalibration', 'itlrealtimeplanning3'. Default: binpicking
            taskzmqport (int, optional): Port of the task's ZMQ server, e.g. 7110
            taskheartbeatport (int, optional): Port of the task's ZMQ server's heartbeat publisher, e.g. 7111
            taskheartbeattimeout (float, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
            ctx (zmq.Context, optional): Seconds until reinitializing task's ZMQ server if no heartbeat is received, e.g. 7
        """
        self.regionname = regionname
        super(BinpickingPlanningClient, self).__init__(robotname=robotname, robotspeed=robotspeed, robotaccelmult=robotaccelmult, envclearance=envclearance, robotBridgeConnectionInfo=robotBridgeConnectionInfo,taskzmqport=taskzmqport, taskheartbeatport=taskheartbeatport, taskheartbeattimeout=taskheartbeattimeout, tasktype=tasktype, scenepk=scenepk, ctx=ctx, slaverequestid=slaverequestid, controllerurl=controllerurl, controllerusername=controllerusername, controllerpassword=controllerpassword, author=author)

    
    #
    # Generated commands
    #

    # ============== Auto-generated code starts here

    def PickAndPlace(
        self,
        goaltype,
        goals,
        targetnamepattern=None,
        approachoffset=30,
        departoffsetdir=[0, 0, 50],
        destdepartoffsetdir=[0, 0, 30],
        deletetarget=0,
        debuglevel=4,
        movetodestination=1,
        freeinc=[0.08],
        worksteplength=None,
        densowavearmgroup=5,
        regionname=None,
        cameranames=None,
        envclearance=None,
        toolname=None,
        robotspeed=None,
        timeout=1000,
        desttargetname=None,
        destikparamnames=None,
        leaveoffsetintool=None,
        graspsetname=None,
        **kwargs
    ):
        """Picks up an object with the targetnamepattern and places it down at one of the goals. First computes the entire plan from robot moving to a grasp and then moving to its destination, then runs it on the real robot. Task finishes once the real robot is at the destination.

        Args:
            goaltype (str): (DEPRECATED) type of the goal, e.g. translationdirection5d or transform6d
            goals (str): (DEPRECATED) flat list of goals, e.g. two 5d ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            targetnamepattern (str, optional): regular expression describing the name of the object. No default will be provided, caller must set this. See https://docs.python.org/2/library/re.html
            approachoffset (float, optional): Distance in millimeters to move straight to the grasp point, e.g. 30 mm (Default: 30)
            departoffsetdir (list, optional): The direction and distance in mm to move the part in global frame (usually along negative gravity) after it is grasped, e.g. [0,0,50] (Default: [0, 0, 50])
            destdepartoffsetdir (list, optional): The direction and distance in mm to move away from the object after it is placed, e.g. [0,0,30]. Depending on leaveoffsetintool parameter, this can in the global coordinate system or tool coordinate system. (Default: [0, 0, 30])
            deletetarget (int, optional): whether to delete target after pick and place is done (Default: 0)
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE. (Default: 4)
            movetodestination (str, optional): planning parameter (Default: 1)
            freeinc (str, optional): planning parameter (Default: [0.08])
            worksteplength (str, optional): planning parameter
            densowavearmgroup (str, optional): planning parameter (Default: 5)
            regionname (str, optional): name of the region of the objects
            cameranames (list, optional): The names of the cameras to avoid occlusions with the robot
            envclearance (float, optional): Environment clearance in millimeters.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            timeout (float, optional): (Default: 1000)
            desttargetname (str, optional): The destination target name where the destination goal ikparams come from
            destikparamnames (str, optional): A list of lists of ikparam names for the destinations of the target. Only destikparamnames[0] is looked at and tells the system to place the part in any of the ikparams in destikparamnames[0]
            leaveoffsetintool (int, optional): If 1, destdepartoffsetdir is in the tool coordinate system. If 0, destdepartoffsetdir is in the global coordinate system. By default this is 0.
            graspsetname (str, optional): the name of the grasp set belong to the target objects to use for the target. Grasp sets are a list of ikparams
        """
        taskparameters = {
            'command': 'PickAndPlace',
            'goaltype': goaltype,
            'goals': goals,
            'approachoffset': approachoffset,
            'departoffsetdir': departoffsetdir,
            'destdepartoffsetdir': destdepartoffsetdir,
            'deletetarget': deletetarget,
            'debuglevel': debuglevel,
            'movetodestination': movetodestination,
            'freeinc': freeinc,
            'densowavearmgroup': densowavearmgroup,
        }
        if targetnamepattern is not None:
            taskparameters['targetnamepattern'] = targetnamepattern
        if worksteplength is not None:
            taskparameters['worksteplength'] = worksteplength
        if regionname is not None:
            taskparameters['regionname'] = regionname
        if cameranames is not None:
            taskparameters['cameranames'] = cameranames
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if desttargetname is not None:
            taskparameters['desttargetname'] = desttargetname
        if destikparamnames is not None:
            taskparameters['destikparamnames'] = destikparamnames
        if leaveoffsetintool is not None:
            taskparameters['leaveoffsetintool'] = leaveoffsetintool
        if graspsetname is not None:
            taskparameters['graspsetname'] = graspsetname
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StartPickAndPlaceThread(
        self,
        goaltype=None,
        goals=None,
        targetnamepattern=None,
        approachoffset=30,
        departoffsetdir=[0, 0, 50],
        destdepartoffsetdir=[0, 0, 30],
        deletetarget=None,
        debuglevel=4,
        movetodestination=1,
        worksteplength=None,
        densowavearmgroup=5,
        regionname=None,
        envclearance=None,
        toolname=None,
        robotspeed=None,
        timeout=10,
        cameranames=None,
        cycledests=None,
        desttargetname=None,
        destikparamnames=None,
        leaveoffsetintool=None,
        graspsetname=None,
        useworkspaceplanner=None,
        forceStartRobotValues=None,
        initiallyDisableRobotBridge=None,
        **kwargs
    ):
        """Start a background loop to continuously pick up objects with the targetnamepattern and place them down at the goals. The loop will check new objects arriving in and move the robot as soon as it finds a feasible grasp. The thread can be quit with StopPickPlaceThread.

        Args:
            goaltype (str, optional): type of the goal, e.g. translationdirection5d
            goals (list, optional): flat list of goals, e.g. two 5d ik goals: [380,450,50,0,0,1, 380,450,50,0,0,-1]
            targetnamepattern (str, optional): regular expression describing the name of the object, no default will be provided, caller must set this. See https://docs.python.org/2/library/re.html
            approachoffset (list, optional): distance in millimeters to move straight to the grasp point, e.g. 30 mm (Default: 30)
            departoffsetdir (list, optional): the direction and distance in mm to move the part in global frame (usually along negative gravity) after it is grasped, e.g. [0,0,50] (Default: [0, 0, 50])
            destdepartoffsetdir (list, optional): the direction and distance in mm to move away from the object after it is placed, e.g. [0,0,30]. Depending on leaveoffsetintool parameter, this can in the global coordinate system or tool coordinate system. (Default: [0, 0, 30])
            deletetarget (int, optional): whether to delete target after pick and place is done
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE. (Default: 4)
            movetodestination (int, optional): planning parameter (Default: 1)
            worksteplength (float, optional): planning parameter
            densowavearmgroup: robot parameters (Default: 5)
            regionname (str, optional): name of the region of the objects
            envclearance (float, optional): Environment clearance in millimeters.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            timeout (float, optional): (Default: 10)
            cameranames (list, optional): the names of the cameras to avoid occlusions with the robot
            cycledests (int, optional): When finished cycling through all destikparamnames, will delete all the targets and start from the first index again doing this for cycledests times. By default it is 1.
            desttargetname (str, optional): The destination target name where the destination goal ikparams come from
            destikparamnames (list, optional): A list of lists of ikparam names for the ordered destinations of the target. destikparamnames[0] is where the first picked up part goes, desttargetname[1] is where the second picked up target goes.
            leaveoffsetintool (int, optional): If 1, destdepartoffsetdir is in the tool coordinate system. If 0, destdepartoffsetdir is in the global coordinate system. By default this is 0.
            graspsetname: the name of the grasp set belong to the target objects to use for the target. Grasp sets are a list of ikparams
            useworkspaceplanner (int, optional): If 1 is set, will try the workspace planner for moving the hand straight. If 2 is set, will try the
            forceStartRobotValues (list[number], optional): planning loop should always start from these values rather than reading from robot
            initiallyDisableRobotBridge (bool, optional): if True, stops any communication with the robotbridge until robot bridge is enabled
        """
        taskparameters = {
            'command': 'StartPickAndPlaceThread',
            'approachoffset': approachoffset,
            'departoffsetdir': departoffsetdir,
            'destdepartoffsetdir': destdepartoffsetdir,
            'debuglevel': debuglevel,
            'movetodestination': movetodestination,
            'densowavearmgroup': densowavearmgroup,
        }
        if goaltype is not None:
            taskparameters['goaltype'] = goaltype
        if goals is not None:
            taskparameters['goals'] = goals
        if targetnamepattern is not None:
            taskparameters['targetnamepattern'] = targetnamepattern
        if deletetarget is not None:
            taskparameters['deletetarget'] = deletetarget
        if worksteplength is not None:
            taskparameters['worksteplength'] = worksteplength
        if regionname is not None:
            taskparameters['regionname'] = regionname
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if cameranames is not None:
            taskparameters['cameranames'] = cameranames
        if cycledests is not None:
            taskparameters['cycledests'] = cycledests
        if desttargetname is not None:
            taskparameters['desttargetname'] = desttargetname
        if destikparamnames is not None:
            taskparameters['destikparamnames'] = destikparamnames
        if leaveoffsetintool is not None:
            taskparameters['leaveoffsetintool'] = leaveoffsetintool
        if graspsetname is not None:
            taskparameters['graspsetname'] = graspsetname
        if useworkspaceplanner is not None:
            taskparameters['useworkspaceplanner'] = useworkspaceplanner
        if forceStartRobotValues is not None:
            taskparameters['forceStartRobotValues'] = forceStartRobotValues
        if initiallyDisableRobotBridge is not None:
            taskparameters['initiallyDisableRobotBridge'] = initiallyDisableRobotBridge
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StopPickPlaceThread(self, resetExecutionState=True, resetStatusPickPlace=False, finishCode=None, timeout=10, fireandforget=False, **kwargs):
        """stops the pick and place thread started with StartPickAndPlaceThread

        Args:
            resetExecutionState (bool, optional): if True, then reset the order state variables. By default True (Default: True)
            resetStatusPickPlace (bool, optional): if True, then reset the statusPickPlace field of hte planning slave. By default False.
            finishCode (str, optional): optional finish code to end the cycle with (if it doesn't end with something else beforehand)
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'StopPickPlaceThread',
            'resetExecutionState': resetExecutionState,
            'resetStatusPickPlace': resetStatusPickPlace,
        }
        if finishCode is not None:
            taskparameters['finishCode'] = finishCode
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetPickPlaceStatus(self, timeout=10, **kwargs):
        """gets the status of the pick and place thread

        Args:
            timeout (float, optional): (Default: 10)

        Returns:
            Status (0: not running, 1: no error, 2: error) of the pick and place thread in a json dictionary, e.g. {'status': 2, 'error': 'an error happened'}

        """
        taskparameters = {
            'command': 'GetPickPlaceStatus',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ComputeIK(self, toolname=None, timeout=10, iktype=None, quaternion=None, translation=None, direction=None, angle=None, freeincvalue=None, filteroptions=None, limit=None, preshape=None, **kwargs):
        """

        Args:
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            timeout (float, optional): (Default: 10)
            iktype (str, optional): grasp (but basically the just the ikparam)
            quaternion (list[float], optional): List specifying the quaternion in w,x,y,z format, e.g. [1,0,0,0].
            translation (list[float], optional): List of x,y,z values of the object in millimeters.
            direction (list, optional): grasp (but basically the just the ikparam) direction in world cooordinates
            angle (float, optional): grasp (but basically the just the ikparam) angle in world cooordinates
            freeincvalue (float, optional): The discretization of the free joints of the robot when computing ik.
            filteroptions (int, optional): OpenRAVE IkFilterOptions bitmask. By default this is 1, which means all collisions are checked
            limit (int, optional): number of solutions to return
            preshape (list, optional): If the tool has fingers after the end effector, specify their values. The gripper DOFs come from **gripper_dof_pks** field from the tool.

        Returns:
            array of IK solutions (each of which is an array of DOF values), sorted by minimum travel distance and truncated to match the limit

        """
        taskparameters = {
            'command': 'ComputeIK',
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if iktype is not None:
            taskparameters['iktype'] = iktype
        if quaternion is not None:
            taskparameters['quaternion'] = quaternion
        if translation is not None:
            taskparameters['translation'] = translation
        if direction is not None:
            taskparameters['direction'] = direction
        if angle is not None:
            taskparameters['angle'] = angle
        if freeincvalue is not None:
            taskparameters['freeincvalue'] = freeincvalue
        if filteroptions is not None:
            taskparameters['filteroptions'] = filteroptions
        if limit is not None:
            taskparameters['limit'] = limit
        if preshape is not None:
            taskparameters['preshape'] = preshape
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def InitializePartsWithPhysics(self, timeout=10, targeturi=None, numtargets=None, regionname=None, duration=None, basename=None, deleteprevious=None, forcegravity=None, **kwargs):
        """Start a physics simulation where the parts drop down into the bin. The method returns as soon as the physics is initialized, user has to wait for the "duration" or call StopPhysicsThread command.

        Args:
            timeout (float, optional): (Default: 10)
            targeturi: the target uri to initialize the scene with
            numtargets: the number of targets to create
            regionname (str, optional): The container name to drop the parts into.
            duration: the duration in seconds to continue the physics until it is stopped.
            basename: The basename to give to all the new target names. Numbers are suffixed at the end, like basename+'0134'. If not specified, will use a basename derived from the targeturi.
            deleteprevious: if True, will delete all the previous targets in the scene. By default this is True.
            forcegravity: if not None, the gravity with which the objects should fall with. If None, then uses the scene's gravity
        """
        taskparameters = {
            'command': 'InitializePartsWithPhysics',
        }
        if targeturi is not None:
            taskparameters['targeturi'] = targeturi
        if numtargets is not None:
            taskparameters['numtargets'] = numtargets
        if regionname is not None:
            taskparameters['regionname'] = regionname
        if duration is not None:
            taskparameters['duration'] = duration
        if basename is not None:
            taskparameters['basename'] = basename
        if deleteprevious is not None:
            taskparameters['deleteprevious'] = deleteprevious
        if forcegravity is not None:
            taskparameters['forcegravity'] = forcegravity
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StopPhysicsThread(self, timeout=10, **kwargs):
        """stops the physics simulation started with InitializePartsWithPhysics

        Args:
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'StopPhysicsThread',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def JitterPartUntilValidGrasp(self, toolname=None, timeout=10, targetname=None, graspsetname=None, approachoffset=None, departoffsetdir=None, destdepartoffsetdir=None, leaveoffsetintool=None, desttargetname=None, destikparamnames=None, jitterangle=None, jitteriters=None, jitterdist=None, **kwargs):
        """Select a part that wasn't able to be grasped and jitter its location such that a grasp set is found for it that will take it to the destination.

        Args:
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            timeout (float, optional): (Default: 10)
            targetname (str, optional): Name of the target object
            graspsetname (str, optional): Name of the grasp set to use
            approachoffset: The approach distance for simulating full grasp.
            departoffsetdir: The depart distance for simulating full grasp.
            destdepartoffsetdir: the direction and distance in mm to move away from the object after it is placed, e.g. [0,0,30]. Depending on leaveoffsetintool parameter, this can in the global coordinate system or tool coordinate system.
            leaveoffsetintool: If 1, destdepartoffsetdir is in the tool coordinate system. If 0, destdepartoffsetdir is in the global coordinate system. By default this is 0.
            desttargetname: The destination target name where the destination goal ikparams come from. If no name is specified, then robot won't consider putting the target into the destination when it searches for grasps.
            destikparamnames: A list of lists of ikparam names for the ordered destinations of the target. destikparamnames[0] is where the first picked up part goes, desttargetname[1] is where the second picked up target goes.
            jitterangle: Amount to jitter the target object's orientation angle
            jitteriters: Number of times to try jittering before giving up.
            jitterdist: Amount to jitter the target object translation by

        Returns:
            If failed, an empty dictionary. If succeeded, a dictionary with the following keys:
                - translation: the new translation of the target part
                - quaternion: the new quaternion of the target part
                - jointvalues: robot joint values that are grasping the part (fingers are at their preshape).
                - graspname: the grasp name used for jointvalues. If empty, then no grasp was found.
                - destikname: the name of the destination ikparam that was chosen with the grasp
                - destjointvalues: robot joint values at one of the specified destinations (fingers are at their final positions).
                - desttranslation: the new translation of the target part
                - destquaternion: the new quaternion of the target part

        """
        taskparameters = {
            'command': 'JitterPartUntilValidGrasp',
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if targetname is not None:
            taskparameters['targetname'] = targetname
        if graspsetname is not None:
            taskparameters['graspsetname'] = graspsetname
        if approachoffset is not None:
            taskparameters['approachoffset'] = approachoffset
        if departoffsetdir is not None:
            taskparameters['departoffsetdir'] = departoffsetdir
        if destdepartoffsetdir is not None:
            taskparameters['destdepartoffsetdir'] = destdepartoffsetdir
        if leaveoffsetintool is not None:
            taskparameters['leaveoffsetintool'] = leaveoffsetintool
        if desttargetname is not None:
            taskparameters['desttargetname'] = desttargetname
        if destikparamnames is not None:
            taskparameters['destikparamnames'] = destikparamnames
        if jitterangle is not None:
            taskparameters['jitterangle'] = jitterangle
        if jitteriters is not None:
            taskparameters['jitteriters'] = jitteriters
        if jitterdist is not None:
            taskparameters['jitterdist'] = jitterdist
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveToDropOff(self, dropOffInfo, robotname=None, robotspeed=None, robotaccelmult=None, execute=1, startvalues=None, envclearance=None, timeout=10, **kwargs):
        """Moves the robot to desired joint angles.

        Args:
            dropOffInfo:
            robotname (str, optional): Name of the robot
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            robotaccelmult (float, optional): Value in (0,1] defining the percentage of acceleration the robot should move at.
            execute (int, optional): If 1, execute the motion. (Default: 1)
            startvalues:
            envclearance (float, optional): Environment clearance in millimeters.
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'MoveToDropOff',
            'dropOffInfo': dropOffInfo,
            'execute': execute,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if robotaccelmult is not None:
            taskparameters['robotaccelmult'] = robotaccelmult
        if startvalues is not None:
            taskparameters['startvalues'] = startvalues
        if envclearance is not None:
            taskparameters['envclearance'] = envclearance
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def IsRobotOccludingBody(self, bodyname, cameraname, timeout=10, **kwargs):
        """returns if the robot is occluding body in the view of the specified camera

        Args:
            bodyname: Name of the object
            cameraname: Name of the camera
            timeout (float, optional): (Default: 10)

        Returns:
            The occlusion state in a json dictionary, e.g. {'occluded': 0}

        """
        taskparameters = {
            'command': 'IsRobotOccludingBody',
            'bodyname': bodyname,
            'cameraname': cameraname,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetPickedPositions(self, unit='m', timeout=10, **kwargs):
        """returns the poses and the timestamps of the picked objects

        Args:
            unit (str, optional): The unit of the given values. (Default: 'm')
            timeout (float, optional): (Default: 10)

        Returns:
            [[1,0,0,0,100,200,300,1389774818.8366449],[1,0,0,0,200,200,300,1389774828.8366449]]}

        """
        taskparameters = {
            'command': 'GetPickedPositions',
            'unit': unit,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GetPickAndPlaceLog(self, timeout=10, num=None, startindex=None, **kwargs):
        """Gets the recent pick-and-place log executed on the binpicking server. The internal server keeps the log around until the next Pick-and-place command is executed.

        Args:
            timeout (float, optional): (Default: 10)
            num (int, optional): Number of trajectories from startindex to return. If 0 will return all the trajectories starting from startindex
            startindex (int, optional): Start of the trajectory to get. If negative, will start counting from the end. For example, -1 is the last element, -2 is the second to last element.

        Returns:
            10
                messages: [
                {
                "message":"message1",
                "type":"",
                "level":0,
                "data": {
                    "jointvalues":[0,0,0,0,0,0]
                }
                },
                ]

        """
        taskparameters = {
            'command': 'GetPickAndPlaceLog',
        }
        if num is not None:
            taskparameters['num'] = num
        if startindex is not None:
            taskparameters['startindex'] = startindex
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def MoveRobotOutOfCameraOcclusion(self, regionname=None, robotspeed=None, toolname=None, timeout=10, cameranames=None, **kwargs):
        """Moves the robot out of camera occlusion and deletes targets if it was in occlusion.

        Args:
            regionname (str, optional): name of the region of the objects
            robotspeed (float, optional): Value in (0,1] defining the percentage of speed the robot should move at.
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            timeout (float, optional): (Default: 10)
            cameranames (list, optional): The names of the cameras to avoid occlusions with the robot
        """
        taskparameters = {
            'command': 'MoveRobotOutOfCameraOcclusion',
        }
        if regionname is not None:
            taskparameters['regionname'] = regionname
        if robotspeed is not None:
            taskparameters['robotspeed'] = robotspeed
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if cameranames is not None:
            taskparameters['cameranames'] = cameranames
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def PausePickPlace(self, timeout=10, **kwargs):
        """

        Args:
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'PausePickPlace',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ResumePickPlace(self, timeout=10, **kwargs):
        """

        Args:
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'ResumePickPlace',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SendStateTrigger(self, stateTrigger, timeout=10, fireandforget=False, **kwargs):
        """

        Args:
            stateTrigger (str): a string that represents a unique trigger
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'SendStateTrigger',
            'stateTrigger': stateTrigger,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetBinpickingState(self, timeout=10, fireandforget=False, **kwargs):
        """

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'GetBinpickingState',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetStopPickPlaceAfterExecutionCycle(self, timeout=10, finishCode=None, **kwargs):
        """Sets the cycle for stopping after the current pick cycle finishes.

        If robot has not grabbed a part yet, then will stop the robot immediately.
        On proper finish of the pick cycle, robot should go back to the finish position.

        Args:
            timeout (float, optional): (Default: 10)
            finishCode: The finish code to end with. If not specified, will be 'FinishedCycleStopped'
        """
        taskparameters = {
            'command': 'SetStopPickPlaceAfterExecutionCycle',
        }
        if finishCode is not None:
            taskparameters['finishCode'] = finishCode
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def PutPartsBack(self, trajectoryxml, numparts, toolname=None, grippervalues=None, timeout=100, **kwargs):
        """Runs saved planningresult trajectories.

        Args:
            trajectoryxml (str):
            numparts (int):
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
            grippervalues (list, optional):
            timeout (float, optional): (Default: 100)
        """
        taskparameters = {
            'command': 'PutPartsBack',
            'trajectory': trajectoryxml,
            'numparts': numparts,
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        if grippervalues is not None:
            taskparameters['grippervalues'] = grippervalues
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def GenerateGraspModelFromIkParams(self, graspsetname, targeturi, toolname, robotname=None, timeout=10, **kwargs):
        """Generates grasp model IK for given setup.

        Args:
            graspsetname (str): Name of the grasp set to use
            targeturi (str): uri of target scene, e.g. '4902201402644.mujin.dae'
            toolname (str): Name of the manipulator. Defaults to currently selected tool
            robotname (str, optional): Name of the robot
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'GenerateGraspModelFromIkParams',
            'graspsetname': graspsetname,
            'targeturi': targeturi,
            'toolname': toolname,
        }
        if robotname is not None:
            taskparameters['robotname'] = robotname
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def CheckGraspModelIk(self, graspsetname, targeturi, toolname, ikparamnames=None, timeout=10, **kwargs):
        """Checks if grasp model is generated for given setup.

        Args:
            graspsetname (str): Name of the grasp set to use
            targeturi: str. uri of target scene like 'mujin:4902201402644.mujin.dae'
            toolname (str): Name of the manipulator. Defaults to currently selected tool
            ikparamnames (list, optional):
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'CheckGraspModelIk',
            'graspsetname': graspsetname,
            'targeturi': targeturi,
            'toolname': toolname,
        }
        if ikparamnames is not None:
            taskparameters['ikparamnames'] = ikparamnames
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def SetCurrentLayoutDataFromPLC(self, containername, containerLayoutSize, destObstacleName, ioVariableName, timeout=10, **kwargs):
        """Sets current layout from PLC.

        Args:
            containername (str):
            containerLayoutSize:
            destObstacleName (str):
            ioVariableName (str):
            timeout (float, optional): (Default: 10)
        """
        taskparameters = {
            'command': 'SetCurrentLayoutDataFromPLC',
            'containername': containername,
            'containerLayoutSize': containerLayoutSize,
            'destObstacleName': destObstacleName,
            'ioVariableName': ioVariableName,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def ClearVisualization(self, timeout=10, fireandforget=False, **kwargs):
        """Clears visualization.

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'ClearVisualization',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetPlanStatistics(self, timeout=10, fireandforget=False, **kwargs):
        """Gets plan and execute statistics of the last pick and place

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'GetPlanStatistics',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SetCurrentLayoutDataSendOnObjectUpdateData(self, doUpdate, containername=None, containerLayoutSize=None, ioVariableName=None, fireandforget=True, **kwargs):
        """Sets currentLayoutDataSendOnObjectUpdateData structure

        Args:
            doUpdate: If True then currentLayoutData will be send on every ObjectUpdate, else currentLayoutDataSendOnObjectUpdate structure is reset
            containername (str, optional):
            containerLayoutSize:
            ioVariableName:
            fireandforget (bool, optional): (Default: True)
        """
        taskparameters = {
            'command': 'SetCurrentLayoutDataSendOnObjectUpdateData',
            'doUpdate': doUpdate,
        }
        if containername is not None:
            taskparameters['containername'] = containername
        if containerLayoutSize is not None:
            taskparameters['containerLayoutSize'] = containerLayoutSize
        if ioVariableName is not None:
            taskparameters['ioVariableName'] = ioVariableName
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, fireandforget=fireandforget)

    def StartPackFormationComputationThread(self, timeout=10, debuglevel=4, toolname=None, **kwargs):
        """Starts a background loop to copmute packing formation.

        Args:
            timeout (float, optional): (Default: 10)
            debuglevel (int, optional): Sets the debug level for the planning logs. For development. 3=INFO, 4=DEBUG, 5=VERBOSE. (Default: 4)
            toolname (str, optional): Name of the manipulator. Defaults to currently selected tool
        """
        taskparameters = {
            'command': 'StartPackFormationComputationThread',
            'debuglevel': debuglevel,
        }
        if toolname is not None:
            taskparameters['toolname'] = toolname
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)

    def StopPackFormationComputationThread(self, timeout=10, fireandforget=False, **kwargs):
        """Stops the packing computation thread thread started with StartPackFormationComputationThread

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'StopPackFormationComputationThread',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def VisualizePackingState(self, timeout=10, fireandforget=False, **kwargs):
        """Stops the packing computation thread thread started with StartPackFormationComputationThread

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'VisualizePackingState',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def VisualizePackFormationResult(self, timeout=10, fireandforget=False, initializeCameraPosition=None):
        """Stops the packing computation thread thread started with StartPackFormationComputationThread

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
            initializeCameraPosition (bool, optional): Reset camera position
        """
        taskparameters = {
            'command': 'VisualizePackFormationResult',
        }
        if initializeCameraPosition is not None:
            taskparameters['initializeCameraPosition'] = initializeCameraPosition
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetPackFormationSolution(self, timeout=10, fireandforget=False, **kwargs):
        """Stops the packing computation thread thread started with StartPackFormationComputationThread

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'GetPackFormationSolution',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetPackItemPoseInWorld(self, timeout=10, fireandforget=False, **kwargs):
        """

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'GetPackItemPoseInWorld',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ManuallyPlacePackItem(self, packFormationComputationResult=None, inputPartIndex=None, placeLocationNames=None, placedTargetPrefix=None, orderNumber=None, numLeftToPick=None, timeout=10, fireandforget=False, **kwargs):
        """Places an item according to the pack formation assuming the item is placed manually and updates robotbridge state

        Args:
            packFormationComputationResult:
            inputPartIndex:
            placeLocationNames:
            placedTargetPrefix:
            orderNumber:
            numLeftToPick:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'ManuallyPlacePackItem',
        }
        if packFormationComputationResult is not None:
            taskparameters['packFormationComputationResult'] = packFormationComputationResult
        if inputPartIndex is not None:
            taskparameters['inputPartIndex'] = inputPartIndex
        if placeLocationNames is not None:
            taskparameters['placeLocationNames'] = placeLocationNames
        if placedTargetPrefix is not None:
            taskparameters['placedTargetPrefix'] = placedTargetPrefix
        if orderNumber is not None:
            taskparameters['orderNumber'] = orderNumber
        if numLeftToPick is not None:
            taskparameters['numLeftToPick'] = numLeftToPick
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def SendPackFormationComputationResult(self, timeout=10, fireandforget=False, **kwargs):
        """Stops the packing computation thread thread started with StartPackFormationComputationThread

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'SendPackFormationComputationResult',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def GetLatestPackFormationResultList(self, timeout=10, fireandforget=False, **kwargs):
        """Gets latest pack formation computation result

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'GetLatestPackFormationResultList',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ClearPackingStateVisualization(self, timeout=10, fireandforget=False, **kwargs):
        """Clears packing visualization

        Args:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):
        """
        taskparameters = {
            'command': 'ClearPackingStateVisualization',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ValidatePackFormationResultList(self, packFormationResultList, timeout=10, fireandforget=False, **kwargs):
        """Validates pack formation result list and compute info (fillRatio, packageDimensions, packedItemsInfo, etc) about it.

        kwargs should be packing parameters'

        Args:
            packFormationResultList:
            timeout (float, optional): (Default: 10)
            fireandforget (bool, optional):

        Returns:
            {'validatedPackFormationResultList':[{'validationStatus', 'errorCode', 'errorDesc', (optional)'packFormationResult'}]}

        """
        taskparameters = {
            'command': 'ValidatePackFormationResultList',
            'packFormationResultList': packFormationResultList,
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout, fireandforget=fireandforget)

    def ComputeSamePartPackResultBySimulation(self, timeout=100, **kwargs):
        """Computes pack formation for single part type.

        Args:
            timeout (float, optional): (Default: 100)
        """
        taskparameters = {
            'command': 'ComputeSamePartPackResultBySimulation',
        }
        taskparameters.update(kwargs)
        return self.ExecuteCommand(taskparameters, timeout=timeout)



# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
